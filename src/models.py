# generated by datamodel-codegen:
#   filename:  QuantConnect-Platform-2.0.0.yaml
#   timestamp: 2025-08-15T14:51:37+00:00

from __future__ import annotations
from pydantic import RootModel, ConfigDict

from datetime import datetime, time
from enum import Enum
from typing import Annotated, Any, Dict, List, Optional, Union

from pydantic import BaseModel, Field


class Language(Enum):
    C_ = 'C#'
    Py = 'Py'


class State(Enum):
    End = 'End'
    Error = 'Error'


class BacktestInitResponse(BaseModel):
    state: Annotated[Optional[State], Field(description='State of the backtest.')] = (
        None
    )
    version: Annotated[
        Optional[float], Field(description='Version of the response.', examples=[2.0])
    ] = None
    payload: Annotated[
        Optional[str],
        Field(description='Information about the backtest initialization.'),
    ] = None
    payloadType: Annotated[
        Optional[str], Field(description='Type of the payload.', examples=['String'])
    ] = None


class CodeCompletionRequest(BaseModel):
    language: Annotated[
        Language,
        Field(
            description='Programming language for the code completion.', examples=['Py']
        ),
    ]
    sentence: Annotated[
        str,
        Field(description='Sentence to complete.', examples=['self.add_eq', 'AddEq']),
    ]
    responseSizeLimit: Annotated[
        Optional[int],
        Field(description='Maximum size of the responses.', examples=[10]),
    ] = None


class State1(Enum):
    End = 'End'


class CodeCompletionResponse(BaseModel):
    state: Annotated[
        Optional[State1], Field(description='State of the code completion.')
    ] = None
    version: Annotated[
        Optional[float], Field(description='Version of the response.', examples=[2.0])
    ] = None
    payload: Annotated[
        Optional[List[str]], Field(description='Code completion suggestions.')
    ] = None
    payloadType: Annotated[
        Optional[str],
        Field(description='Type of the payload.', examples=['StringArray']),
    ] = None


class ErrorEnhanceResponse(BaseModel):
    state: Annotated[
        Optional[str],
        Field(description='State of the code completion.', examples=['End']),
    ] = None
    version: Annotated[
        Optional[float], Field(description='Version of the response.', examples=[2.0])
    ] = None
    payload: Annotated[
        Optional[str], Field(description='Error message suggestions.')
    ] = None
    payloadType: Annotated[
        Optional[str], Field(description='Type of the payload.', examples=['String'])
    ] = None


class PEP8ConvertResponse(BaseModel):
    state: Annotated[
        Optional[str], Field(description='State of PEP8 conversion.', examples=['End'])
    ] = None
    version: Annotated[
        Optional[float], Field(description='Version of the response.', examples=[2.0])
    ] = None
    payload: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='A dictionary where the key is the file name and the value is the PEP8 converted code of that file.',
            examples=[{'utils.py': 'def add(a,b):\n    return a+b\n'}],
        ),
    ] = None
    payloadType: Annotated[
        Optional[str],
        Field(description='Type of the payload.', examples=['StringDict']),
    ] = None


class State2(Enum):
    End = 'End'
    Error = 'Error'


class SyntaxCheckResponse(BaseModel):
    state: Annotated[
        Optional[State2], Field(description='State of the syntax check.')
    ] = None
    version: Annotated[
        Optional[float], Field(description='Version of the response.', examples=[2.0])
    ] = None
    payload: Annotated[
        Optional[List[str]], Field(description='Code completion suggestions.')
    ] = None
    payloadType: Annotated[
        Optional[str],
        Field(description='Type of the payload.', examples=['StringArray']),
    ] = None


class Type(Enum):
    Stubs = 'Stubs'
    Forum = 'Forum'
    Docs = 'Docs'
    Examples = 'Examples'


class SearchCriteria(BaseModel):
    input: Annotated[
        str,
        Field(
            description='Input for the search.',
            examples=['option', 'How to create an Alpha model'],
        ),
    ]
    type: Annotated[Type, Field(description='Type of the search criteria.')]
    count: Annotated[
        int, Field(description='Number of results to return.', examples=[1])
    ]


class SearchRetrieval(BaseModel):
    url: Annotated[
        Optional[str],
        Field(
            description='Input for the search.',
            examples=[
                '[Index Options - QuantConnect.com](https://www.quantconnect.com/docs/v2/writing-algorithms/universes/index-options)'
            ],
        ),
    ] = None
    score: Annotated[
        Optional[float],
        Field(
            description='Relevance score of the search result.', examples=[0.320344448]
        ),
    ] = None
    content: Annotated[
        Optional[str], Field(description='Content of the search result.')
    ] = None
    type: Annotated[
        Optional[float],
        Field(
            description='Type of the search result. 0=Stubs, 1=Forum, 2=Docs, 3=Examples.',
            examples=[2],
        ),
    ] = None


class AbortOptimizationRequest(BaseModel):
    optimizationId: Annotated[
        str,
        Field(
            description='Id of the optimization to abort.',
            examples=['O-401d3d40b5a0e9f8c46c954a303f3ddd'],
        ),
    ]


class BacktestReport(BaseModel):
    report: Annotated[
        Optional[str],
        Field(description='HTML data of the report with embedded base64 images.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class BacktestReportGeneratingResponse(BaseModel):
    generating: Annotated[
        Optional[bool], Field(description='Indicate if the report is generating.')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class BacktestReportRequest(BaseModel):
    projectId: Annotated[
        int, Field(description='Id of the project to read.', examples=[23456789])
    ]
    backtestId: Annotated[
        str,
        Field(
            description='Id of the backtest to read.',
            examples=['26c7bb06b8487cff1c7b3c44652b30f1'],
        ),
    ]


class Status(Enum):
    Completed_ = 'Completed.'
    In_Queue___ = 'In Queue...'
    Running_____ = '\'Running: _%\''
    Runtime_Error = 'Runtime Error'


class Environment(Enum):
    live = 'live'
    paper = 'paper'


class BaseLiveAlgorithmSettings(BaseModel):
    id: Annotated[
        Optional[str],
        Field(
            description="'Interactive' / 'FXCM' / 'Oanda' / 'Tradier' /'PaperTrading'",
            examples=['Default'],
        ),
    ] = None
    user: Annotated[
        Optional[str],
        Field(description='Username associated with brokerage.', examples=['']),
    ] = None
    password: Annotated[
        Optional[str],
        Field(description='Password associated with brokerage.', examples=['']),
    ] = None
    environment: Annotated[
        Optional[Environment],
        Field(
            description='Represents the types of environments supported by brokerages for trading.'
        ),
    ] = None
    account: Annotated[
        Optional[str],
        Field(description='Account of the associated brokerage.', examples=['']),
    ] = None


class BrokerageId(BaseModel):
    id: Annotated[Optional[str], Field(description='The ID of the brokerage.')] = None


class Card(BaseModel):
    brand: Annotated[Optional[str], Field(description='Credit card brand.')] = None
    expiration: Annotated[
        Optional[str],
        Field(description='The credit card expiration (mm/yy).', examples=['12/27']),
    ] = None
    last4: Annotated[
        Optional[str], Field(description='The last 4 digits of the card.')
    ] = None


class SecuritySymbol(BaseModel):
    value: Annotated[Optional[str], Field(description='TODO')] = None
    id: Annotated[Optional[str], Field(description='TODO')] = None
    permtick: Annotated[Optional[str], Field(description='TODO')] = None


class Cash(BaseModel):
    securitySymbols: Optional[List[SecuritySymbol]] = None
    symbol: Annotated[
        Optional[str], Field(description='Gets the symbol used to represent this cash.')
    ] = None
    amount: Annotated[
        Optional[float], Field(description='Gets or sets the amount of cash held.')
    ] = None
    conversionRate: Annotated[
        Optional[float],
        Field(description='The currency conversion rate to the account base currency.'),
    ] = None
    currencySymbol: Annotated[
        Optional[str], Field(description='The symbol of the currency.', examples=['$'])
    ] = None
    valueInAccountCurrency: Annotated[
        Optional[float],
        Field(
            description='The value of the currency cash in the account base currency.'
        ),
    ] = None


class CashAmount(BaseModel):
    amount: Annotated[Optional[float], Field(description='The amount of cash.')] = None
    currency: Annotated[
        Optional[str],
        Field(description='The currency in which the cash amount is denominated.'),
    ] = None


class ChartSummary(BaseModel):
    name: Annotated[Optional[str], Field(description='Name of the Chart.')] = None


class ChartType(Enum):
    integer_0 = 0
    integer_1 = 1


class ChartPoint(BaseModel):
    x: Annotated[
        Optional[str],
        Field(
            description='Time of this chart point: lower case for javascript encoding simplicty.'
        ),
    ] = None
    y: Annotated[
        Optional[float],
        Field(
            description='Value of this chart point:  lower case for javascript encoding simplicty.'
        ),
    ] = None


class CreateCompileRequest(BaseModel):
    projectId: Annotated[
        int, Field(description='Id of the project to compile.', examples=[23456789])
    ]


class Permission(Enum):
    read = 'read'
    write = 'write'


class Collaborator(BaseModel):
    uid: Annotated[Optional[int], Field(description='User ID.')] = None
    liveControl: Annotated[
        Optional[bool], Field(description='Indicate if the user has live control.')
    ] = None
    permission: Annotated[
        Optional[Permission], Field(description='The permission this user is given.')
    ] = None
    publicId: Annotated[Optional[str], Field(description='The user public ID.')] = None
    profileImage: Annotated[
        Optional[str],
        Field(
            description='The url of the user profile image.',
            examples=['https://cdn.quantconnect.com/web/i/users/profile/abc123.jpeg'],
        ),
    ] = None
    email: Annotated[
        Optional[str],
        Field(
            description='The registered email of the user.', examples=['abc@123.com']
        ),
    ] = None
    name: Annotated[
        Optional[str], Field(description='The display name of the user.')
    ] = None
    bio: Annotated[Optional[str], Field(description='The biography of the user.')] = (
        None
    )
    owner: Annotated[
        Optional[bool],
        Field(description='Indicate if the user is the owner of the project.'),
    ] = None


class CreateCollaboratorRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project to add the collaborator to.',
            examples=[23456789],
        ),
    ]
    collaboratorUserId: Annotated[
        str,
        Field(description='User Id of the collaborator to add.', examples=['mia-ai']),
    ]
    collaborationLiveControl: Annotated[
        bool,
        Field(
            description='Gives the right to deploy and stop live algorithms.',
            examples=[True],
        ),
    ]
    collaborationWrite: Annotated[
        bool, Field(description='Gives the right to edit the code.', examples=[False])
    ]


class CreateCollaboratorResponse(BaseModel):
    collaborators: Annotated[
        Optional[List[Collaborator]], Field(description='List of collaborators.')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None


class ReadCollaboratorsRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project from which to read the collaborators.',
            examples=[23456789],
        ),
    ]


class UserPermissions(Enum):
    write = 'write'
    read = 'read'


class ReadCollaboratorsResponse(BaseModel):
    collaborators: Annotated[
        Optional[List[Collaborator]],
        Field(description='List of collaborators on the project.'),
    ] = None
    userLiveControl: Annotated[
        Optional[bool],
        Field(
            description='Indicate if the project owner has the right to deploy and stop live algorithms.'
        ),
    ] = None
    userPermissions: Annotated[
        Optional[UserPermissions], Field(description='Permissions of the project owner')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None


class UpdateCollaboratorRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project the collaborator is on.', examples=[23456789]
        ),
    ]
    collaboratorUserId: Annotated[
        str,
        Field(
            description='User Id of the collaborator to update.', examples=['mia-ai']
        ),
    ]
    liveControl: Annotated[
        bool,
        Field(
            description='Gives the right to deploy and stop live algorithms.',
            examples=[True],
        ),
    ]
    write: Annotated[
        bool, Field(description='Gives the right to edit the code.', examples=[True])
    ]


class UpdateCollaboratorResponse(BaseModel):
    collaborators: Annotated[
        Optional[List[Collaborator]], Field(description='List of collaborators.')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None


class DeleteCollaboratorRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project to remove the collaborator from.',
            examples=[23456789],
        ),
    ]
    collaboratorId: Annotated[
        str,
        Field(
            description='User Id of the collaborator to remove.', examples=['mia-ai']
        ),
    ]


class DeleteCollaboratorResponse(BaseModel):
    collaborators: Annotated[
        Optional[List[Collaborator]], Field(description='List of collaborators.')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None


class LockCollaboratorRequest(BaseModel):
    projectId: Annotated[
        int, Field(description='Id of the project to edit.', examples=[23456789])
    ]
    codeSourceId: Annotated[
        str,
        Field(
            description="Name of the environment that's creating the request.",
            examples=['MCP Server'],
        ),
    ]


class State4(Enum):
    InQueue = 'InQueue'
    BuildSuccess = 'BuildSuccess'
    BuildError = 'BuildError'


class ReadCompileResponse(BaseModel):
    compileId: Annotated[
        Optional[str],
        Field(
            description='Compile Id for a successful build.',
            examples=[
                '5d1f2cba3a0ec7407c566614300502b5-173e0419674daf4144ce7c9931155ca8'
            ],
        ),
    ] = None
    state: Annotated[
        Optional[State4], Field(description='The current state of the compile job.')
    ] = None
    logs: Annotated[
        Optional[List[str]], Field(description='Logs of the compilation request.')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class ParameterDetail(BaseModel):
    line: Annotated[
        Optional[int],
        Field(
            description='Line number where the parameter was detected.', examples=[8]
        ),
    ] = None
    type: Annotated[
        Optional[str],
        Field(
            description='Description of the detected parameter.',
            examples=[
                '3 LEAN API parameters detected near "self.set_start_date(2024, 1, 3)".'
            ],
        ),
    ] = None


class CreateBacktestRequest(BaseModel):
    projectId: Annotated[
        int, Field(description='Id of the project to backtest.', examples=[23456789])
    ]
    compileId: Annotated[
        str,
        Field(
            description='Compile Id for the project to backtest.',
            examples=[
                '5d1f2cba3a0ec7407c566614300502b5-173e0419674daf4144ce7c9931155ca8'
            ],
        ),
    ]
    backtestName: Annotated[
        str, Field(description='Name for the new backtest.', examples=['New Backtest'])
    ]
    parameters: Annotated[
        Optional[Dict[str, Union[str, float, int]]],
        Field(description='Parameters to use for the backtest.'),
    ] = None


class Brokerage(Enum):
    alpaca = 'alpaca'
    tradestation = 'tradestation'
    charlesschwab = 'charlesschwab'
    tastytrade = 'tastytrade'


class AuthorizeExternalConnectionRequest(BaseModel):
    brokerage: Annotated[
        Brokerage, Field(description='The brokerage to authenticate a connection with.')
    ]


class AuthorizeExternalConnectionResponse(BaseModel):
    authorization: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='Authentication information from the data provider or brokerage, including the access token or refresh token.',
            examples=[{'alpaca-access-token': '37a2c4f3-7b1c-41a4-b103-197a88ef2a4d'}],
        ),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class Id(Enum):
    QuantConnectBrokerage = 'QuantConnectBrokerage'


class QuantConnectDataProviderSettings(BaseModel):
    id: Annotated[Id, Field(description='Id of the module.')]


class Id2(Enum):
    InteractiveBrokersBrokerage = 'InteractiveBrokersBrokerage'


class InteractiveBrokersBrokerageSettings(BaseModel):
    id: Annotated[Id2, Field(description='Id of the module.')]
    ib_user_name: Annotated[
        str,
        Field(alias='ib-user-name', description='Your Interactive Brokers username.'),
    ]
    ib_account: Annotated[
        str,
        Field(alias='ib-account', description='Your Interactive Brokers account id.'),
    ]
    ib_password: Annotated[
        str,
        Field(alias='ib-password', description='Your Interactive Brokers password.'),
    ]
    ib_weekly_restart_utc_time: Annotated[
        str,
        Field(
            alias='ib-weekly-restart-utc-time',
            description='Weekly restart UTC time (hh:mm:ss). Each week on Sunday your algorithm restarts at this time and requires 2FA verification. This is required by Interactive Brokers.',
        ),
    ]
    ib_financial_advisors_group_filter: Annotated[
        Optional[str],
        Field(
            alias='ib-financial-advisors-group-filter',
            description='Use this field to filter data by a specific financial advisor group within your Interactive Brokers account. Leave blank to include all groups.',
        ),
    ] = None


class InteractiveBrokersDataProviderSettings(InteractiveBrokersBrokerageSettings):
    pass


class Id3(Enum):
    TradierBrokerage = 'TradierBrokerage'


class TradierEnvironment(Enum):
    live = 'live'
    paper = 'paper'


class TradierBrokerageSettings(BaseModel):
    id: Annotated[Id3, Field(description='Id of the module.')]
    tradier_account_id: Annotated[
        str, Field(alias='tradier-account-id', description='Your Tradier account id.')
    ]
    tradier_access_token: Annotated[
        str,
        Field(alias='tradier-access-token', description='Your Tradier access token.'),
    ]
    tradier_environment: Annotated[
        TradierEnvironment,
        Field(
            alias='tradier-environment',
            description='Whether the developer sandbox should be used.',
        ),
    ]


class TradierDataProviderSettings(TradierBrokerageSettings):
    pass


class Id4(Enum):
    BitfinexBrokerage = 'BitfinexBrokerage'


class BitfinexSettings(BaseModel):
    id: Annotated[Id4, Field(description='Id of the module.')]
    bitfinex_api_key: Annotated[
        str, Field(alias='bitfinex-api-key', description='Your Bitfinex API key.')
    ]
    bitfinex_api_secret: Annotated[
        str, Field(alias='bitfinex-api-secret', description='Your Bitfinex API secret.')
    ]


class Id5(Enum):
    CoinbaseBrokerage = 'CoinbaseBrokerage'


class CoinbaseBrokerageAndDataProviderSettings(BaseModel):
    id: Annotated[Id5, Field(description='Id of the module.')]
    coinbase_api_name: Annotated[
        str,
        Field(
            alias='coinbase-api-name',
            description='Your Coinbase Advanced Trade API name.',
        ),
    ]
    coinbase_api_private_key: Annotated[
        str,
        Field(
            alias='coinbase-api-private-key',
            description='Your Coinbase Advanced Trade API private key.',
        ),
    ]


class CoinbaseDataProviderSettings(CoinbaseBrokerageAndDataProviderSettings):
    pass


class Id6(Enum):
    BinanceBrokerage = 'BinanceBrokerage'


class BinanceExchangeName(Enum):
    Binance = 'Binance'


class BinanceUseTestnet(Enum):
    live = 'live'
    paper = 'paper'


class BinanceBrokerageAndDataProviderSettings(BaseModel):
    id: Annotated[Id6, Field(description='Id of the module.')]
    binance_exchange_name: Annotated[
        BinanceExchangeName,
        Field(alias='binance-exchange-name', description='Binance exchange name.'),
    ]
    binance_api_key: Annotated[
        str, Field(alias='binance-api-key', description='Your Binance API key')
    ]
    binance_api_secret: Annotated[
        str, Field(alias='binance-api-secret', description='Your Binance API secret')
    ]
    binance_use_testnet: Annotated[
        BinanceUseTestnet,
        Field(
            alias='binance-use-testnet',
            description='Whether the testnet should be used',
        ),
    ]


class BinanceDataProviderSettings(BinanceBrokerageAndDataProviderSettings):
    pass


class BinanceExchangeName1(Enum):
    BinanceUS = 'BinanceUS'


class BinanceUSBrokerageAndDataProviderSettings(BaseModel):
    id: Annotated[Id6, Field(description='Id of the module.')]
    binance_exchange_name: Annotated[
        BinanceExchangeName1,
        Field(alias='binance-exchange-name', description='Binance exchange name.'),
    ]
    binanceus_api_key: Annotated[
        str, Field(alias='binanceus-api-key', description='Your Binance API key')
    ]
    binanceus_api_secret: Annotated[
        str, Field(alias='binanceus-api-secret', description='Your Binance API secret')
    ]


class BinanceUSDataProviderSettings(BinanceUSBrokerageAndDataProviderSettings):
    pass


class BinanceExchangeName2(Enum):
    Binance_USDM_Futures = 'Binance-USDM-Futures'


class BinanceUSDMFuturesBrokerageAndDataProviderSettings(BaseModel):
    id: Annotated[Id6, Field(description='Id of the module.')]
    binance_exchange_name: Annotated[
        BinanceExchangeName2,
        Field(alias='binance-exchange-name', description='Binance exchange name.'),
    ]
    binance_api_key: Annotated[
        str, Field(alias='binance-api-key', description='Your Binance API key')
    ]
    binance_api_secret: Annotated[
        str, Field(alias='binance-api-secret', description='Your Binance API secret')
    ]


class BinanceUSDMFuturesDataProviderSettings(
    BinanceUSDMFuturesBrokerageAndDataProviderSettings
):
    pass


class BinanceExchangeName3(Enum):
    Binance_COIN_Futures = 'Binance-COIN-Futures'


class BinanceCOINFuturesBrokerageAndDataProviderSettings(BaseModel):
    id: Annotated[Id6, Field(description='Id of the module.')]
    binance_exchange_name: Annotated[
        BinanceExchangeName3,
        Field(alias='binance-exchange-name', description='Binance exchange name.'),
    ]
    binance_api_key: Annotated[
        str, Field(alias='binance-api-key', description='Your Binance API key')
    ]
    binance_api_secret: Annotated[
        str, Field(alias='binance-api-secret', description='Your Binance API secret')
    ]


class BinanceCOINFuturesDataProviderSettings(
    BinanceCOINFuturesBrokerageAndDataProviderSettings
):
    pass


class Id10(Enum):
    TradingTechnologiesBrokerage = 'TradingTechnologiesBrokerage'


class TtRestEnvironment(Enum):
    live = 'live'
    uat = 'uat'


class TradingTechnologiesBrokerageSettings(BaseModel):
    id: Annotated[Id10, Field(description='Id of the module.')]
    tt_user_name: Annotated[
        str,
        Field(alias='tt-user-name', description='Your Trading Technologies username'),
    ]
    tt_session_password: Annotated[
        str,
        Field(
            alias='tt-session-password',
            description='Your Trading Technologies session password',
        ),
    ]
    tt_account_name: Annotated[
        str,
        Field(
            alias='tt-account-name',
            description='Your Trading Technologies account name',
        ),
    ]
    tt_rest_app_key: Annotated[
        str,
        Field(
            alias='tt-rest-app-key',
            description='Your Trading Technologies REST app key',
        ),
    ]
    tt_rest_app_secret: Annotated[
        str,
        Field(
            alias='tt-rest-app-secret',
            description='Your Trading Technologies REST app secret',
        ),
    ]
    tt_rest_environment: Annotated[
        TtRestEnvironment,
        Field(
            alias='tt-rest-environment', description='The REST environment to run in'
        ),
    ]
    tt_order_routing_sender_comp_id: Annotated[
        str,
        Field(
            alias='tt-order-routing-sender-comp-id',
            description='The order routing sender comp id to use',
        ),
    ]
    cash: Annotated[List[CashAmount], Field(description='List of cash amount.')]


class Id11(Enum):
    KrakenBrokerage = 'KrakenBrokerage'


class KrakenVerificationTier(Enum):
    Starter = 'Starter'
    Intermediate = 'Intermediate'
    Pro = 'Pro'


class KrakenSettings(BaseModel):
    id: Annotated[Id11, Field(description='Id of the module.')]
    kraken_api_key: Annotated[
        str, Field(alias='kraken-api-key', description='Your Kraken API key.')
    ]
    kraken_api_secret: Annotated[
        str, Field(alias='kraken-api-secret', description='Your Kraken API secret.')
    ]
    kraken_verification_tier: Annotated[
        KrakenVerificationTier,
        Field(
            alias='kraken-verification-tier',
            description='Your Kraken Verification Tier.',
        ),
    ]


class Id12(Enum):
    AlpacaBrokerage = 'AlpacaBrokerage'


class AlpacaEnvironment(Enum):
    live = 'live'
    paper = 'paper'


class AlpacaBrokerageSettings(BaseModel):
    id: Annotated[Id12, Field(description='Id of the module.')]
    alpaca_access_token: Annotated[
        str,
        Field(
            alias='alpaca-access-token',
            description='Your Alpaca access token for authentication.',
        ),
    ]
    alpaca_environment: Annotated[
        AlpacaEnvironment,
        Field(
            alias='alpaca-environment',
            description='The environment to run the algorithm in.',
        ),
    ]


class AlpacaDataProviderSettings(BaseModel):
    id: Annotated[Id12, Field(description='Id of the module.')]
    alpaca_api_key: Annotated[
        str, Field(alias='alpaca-api-key', description='Your Alpaca API key.')
    ]
    alpaca_api_secret: Annotated[
        str, Field(alias='alpaca-api-secret', description='Your Alpaca API secret.')
    ]


class Id14(Enum):
    Polygon = 'Polygon'


class PolygonDataProviderSettings(BaseModel):
    id: Annotated[Id14, Field(description='Id of the module.')]
    polygon_api_key: Annotated[
        str, Field(alias='polygon-api-key', description='Your Polygon.io API Key.')
    ]


class Id15(Enum):
    BybitBrokerage = 'BybitBrokerage'


class BybitVipLevel(Enum):
    VIP0 = 'VIP0'
    VIP1 = 'VIP1'
    VIP2 = 'VIP2'
    VIP3 = 'VIP3'
    VIP4 = 'VIP4'
    VIP5 = 'VIP5'
    SupremeVIP = 'SupremeVIP'
    Pro1 = 'Pro1'
    Pro2 = 'Pro2'
    Pro3 = 'Pro3'
    Pro4 = 'Pro4'
    Pro5 = 'Pro5'


class BybitBrokerageAndDataProviderSettings(BaseModel):
    id: Annotated[Id15, Field(description='Id of the module.')]
    bybit_api_key: Annotated[
        str, Field(alias='bybit-api-key', description='Your Bybit API key')
    ]
    bybit_api_secret: Annotated[
        str, Field(alias='bybit-api-secret', description='Your Bybit API secret')
    ]
    bybit_vip_level: Annotated[
        BybitVipLevel,
        Field(alias='bybit-vip-level', description='Your Bybit VIP Level'),
    ]


class BybitDataProviderSettings(BybitBrokerageAndDataProviderSettings):
    pass


class Id16(Enum):
    OandaBrokerage = 'OandaBrokerage'


class OandaEnvironment(Enum):
    Practice = 'Practice'
    Trade = 'Trade'


class OandaSettings(BaseModel):
    id: Annotated[Id16, Field(description='Id of the module.')]
    oanda_account_id: Annotated[
        str,
        Field(
            alias='oanda-account-id',
            description="Your OANDA account id can be found on your OANDA Account Statement page (https://www.oanda.com/account/statement/). It follows the following format '###-###-######-###'.",
        ),
    ]
    oanda_access_token: Annotated[
        str,
        Field(
            alias='oanda-access-token',
            description='Your OANDA API token. You can generate an API token from the Manage API Access page (https://www.oanda.com/account/tpa/personal_token).',
        ),
    ]
    oanda_environment: Annotated[
        OandaEnvironment,
        Field(
            alias='oanda-environment',
            description='The environment to run in. Practice for fxTrade Practice, Trade for fxTrade.',
        ),
    ]


class Id17(Enum):
    WolverineBrokerage = 'WolverineBrokerage'


class Id18(Enum):
    TradeStationBrokerage = 'TradeStationBrokerage'


class TradeStationEnvironment(Enum):
    live = 'live'
    paper = 'paper'


class TradeStationSettings(BaseModel):
    id: Annotated[Id18, Field(description='Id of the module.')]
    trade_station_client_id: Annotated[
        str,
        Field(
            alias='trade-station-client-id', description='Your TradeStation client Id.'
        ),
    ]
    trade_station_account_id: Annotated[
        str,
        Field(
            alias='trade-station-account-id', description='The TradeStation account Id.'
        ),
    ]
    trade_station_refresh_token: Annotated[
        str,
        Field(
            alias='trade-station-refresh-token',
            description='The TradeStation refresh token.',
        ),
    ]
    trade_station_environment: Annotated[
        TradeStationEnvironment,
        Field(
            alias='trade-station-environment',
            description='The environment to run the algorithm in.',
        ),
    ]


class Id19(Enum):
    TastytradeBrokerage = 'TastytradeBrokerage'


class TastytradeSettings(BaseModel):
    id: Annotated[Id19, Field(description='Id of the module.')]
    tastytrade_account_number: Annotated[
        int,
        Field(
            alias='tastytrade-account-number',
            description='Your Tastytrade account number.',
        ),
    ]
    tastytrade_refresh_token: Annotated[
        str,
        Field(
            alias='tastytrade-refresh-token',
            description='The TradeStation refresh token.',
        ),
    ]


class Id20(Enum):
    CharlesSchwabBrokerage = 'CharlesSchwabBrokerage'


class CharlesSchwabSettings(BaseModel):
    id: Annotated[Id20, Field(description='Id of the module.')]
    charles_schwab_account_number: Annotated[
        str,
        Field(
            alias='charles-schwab-account-number',
            description='Your Charles Schwab account number.',
        ),
    ]


class Id21(Enum):
    TerminalLinkBrokerage = 'TerminalLinkBrokerage'


class TerminalLinkConnectionType(Enum):
    SAPI = 'SAPI'


class TerminalLinkEnvironment(Enum):
    Production = 'Production'
    Beta = 'Beta'


class Id22(Enum):
    RBIBrokerage = 'RBIBrokerage'


class CreateLiveCommandRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Project for the live instance we want to run the command against.',
            examples=[23456789],
        ),
    ]
    command: Annotated[
        Dict[str, Any],
        Field(
            description='The command to run.',
            examples=[
                {
                    '$type': 'OrderCommand',
                    'symbol': {'id': 'BTCUSD 2XR', 'value': 'BTCUSD'},
                    'order_type': 'market',
                    'quantity': '0.1',
                    'limit_price': 0,
                    'stop_price': 0,
                    'tag': '',
                }
            ],
        ),
    ]


class BroadcastLiveCommandRequest(BaseModel):
    organizationId: Annotated[
        str,
        Field(
            description='Organization Id of the projects we would like to broadcast the command to',
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ]
    excludeProjectId: Annotated[
        Optional[int],
        Field(
            description='Project for the live instance we want to exclude from the broadcast list. If null, all projects will be included.',
            examples=[23456789],
        ),
    ] = None
    command: Annotated[
        Dict[str, Any],
        Field(
            description='The command to run.',
            examples=[
                {
                    '$type': 'OrderCommand',
                    'symbol': {'id': 'BTCUSD 2XR', 'value': 'BTCUSD'},
                    'order_type': 'market',
                    'quantity': '0.1',
                    'limit_price': 0,
                    'stop_price': 0,
                    'tag': '',
                }
            ],
        ),
    ]


class CreateProjectRequest(BaseModel):
    name: Annotated[str, Field(description='Project name.')]
    language: Annotated[Language, Field(description='Programming language to use.')]
    organizationId: Annotated[
        Optional[str],
        Field(
            description="The organization to create project under. If you don't provide a value, it defaults to your preferred organization.",
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ] = None


class CreateProjectFileRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(description='Id of the project to add the file.', examples=[23456789]),
    ]
    name: Annotated[
        str,
        Field(
            description='The name of the new file.',
            examples=[
                'alpha.py',
                'signal_research.ipynb',
                'indicators/momentum.py',
                'Alpha.cs',
                'SignalResearch.ipynb',
                'Indicators/Momentum.cs',
            ],
        ),
    ]
    content: Annotated[
        Optional[str],
        Field(
            description='The content of the new file.',
            examples=[
                'class CustomClass:\n    def __init__(self):\n        pass\n',
                'public class CustomClass\n{\n    CustomClass()\n    {\n\n    }\n}\n',
                '{"cells": [{"cell_type": "code", "execution_count": null, "metadata": {"pycharm": {"name": "#%%\\n"}}, "outputs": [], "source": ["# Hello world!\\n"]}], "metadata": {"kernelspec": {"display_name": "Python 3", "language": "python", "name": "python3"}, "language_info": {"codemirror_mode": {"name": "ipython", "version": 3}, "file_extension": ".py", "mimetype": "text/x-python", "name": "python", "nbconvert_exporter": "python", "pygments_lexer": "ipython3", "version": "3.6.8"}}, "nbformat": 4, "nbformat_minor": 2}',
                '{"cells": [{"cell_type": "code", "execution_count": 1, "metadata": {}, "outputs": [], "source": ["// We need to load assemblies at the start in their own cell\\n", "#load \\"../Initialize.csx\\""]}], "metadata": {"kernelspec": {"display_name": ".NET (C#)", "language": "C#", "name": "csharp"}, "language_info": {"file_extension": ".cs", "mimetype": "text/x-csharp", "name": "C#", "pygments_lexer": "csharp", "version": "9.0"}}, "nbformat": 4, "nbformat_minor": 2}',
            ],
        ),
    ] = None
    codeSourceId: Annotated[
        Optional[str],
        Field(
            description="Name of the environment that's creating the request.",
            examples=['MCP Server'],
        ),
    ] = None


class DeleteFileRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project that contains the file.', examples=[23456789]
        ),
    ]
    name: Annotated[
        str,
        Field(
            description='The name of the file to delete.',
            examples=['file.py', 'File.cs'],
        ),
    ]
    codeSourceId: Annotated[
        Optional[str],
        Field(
            description="Name of the environment that's creating the request.",
            examples=['MCP Server'],
        ),
    ] = None


class DeleteProjectRequest(BaseModel):
    projectId: Annotated[
        int, Field(description='Id of the project to delete.', examples=[23456789])
    ]


class DeleteBacktestRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project that contains the backtest.',
            examples=[23456789],
        ),
    ]
    backtestId: Annotated[
        str,
        Field(
            description='Id of the backtest to delete.',
            examples=['26c7bb06b8487cff1c7b3c44652b30f1'],
        ),
    ]


class DeleteObjectStoreRequest(BaseModel):
    organizationId: Annotated[
        str,
        Field(
            description='Id of the organization that owns the Object Store.',
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ]
    key: Annotated[
        str,
        Field(description='Key of the Object Store file to delete.', examples=['key1']),
    ]


class DeleteOptimizationRequest(BaseModel):
    optimizationId: Annotated[
        str,
        Field(
            description='Id of the optimization to delete.',
            examples=['O-401d3d40b5a0e9f8c46c954a303f3ddd'],
        ),
    ]


class EncryptionKey(BaseModel):
    id: Annotated[Optional[str], Field(description='Encryption key id.')] = None
    name: Annotated[Optional[str], Field(description='Name of the encryption key.')] = (
        None
    )


class Estimate(BaseModel):
    estimateId: Annotated[Optional[str], Field(description='Estimate Id.')] = None
    time: Annotated[
        Optional[int],
        Field(
            description='Estimated time in seconds to run the optimization job.',
            examples=[60],
        ),
    ] = None
    balance: Annotated[
        Optional[int],
        Field(description="The organization's QCC balance.", examples=[10]),
    ] = None


class OptimizationTargetStatistic(Enum):
    TotalPerformance_PortfolioStatistics_SharpeRatio = (
        'TotalPerformance.PortfolioStatistics.SharpeRatio'
    )
    TotalPerformance_PortfolioStatistics_CompoundingAnnualReturn = (
        'TotalPerformance.PortfolioStatistics.CompoundingAnnualReturn'
    )
    TotalPerformance_PortfolioStatistics_ProbabilisticSharpeRatio = (
        'TotalPerformance.PortfolioStatistics.ProbabilisticSharpeRatio'
    )
    TotalPerformance_PortfolioStatistics_Drawdown = (
        'TotalPerformance.PortfolioStatistics.Drawdown'
    )


class OptimizationTargetTo(Enum):
    min = 'min'
    max = 'max'


class OptimizationStrategy(Enum):
    QuantConnect_Optimizer_Strategies_GridSearchOptimizationStrategy = (
        'QuantConnect.Optimizer.Strategies.GridSearchOptimizationStrategy'
    )


class EstimateOptimizationResponse(BaseModel):
    estimate: Optional[Estimate] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class GetObjectStoreJobIdRequest(BaseModel):
    organizationId: Annotated[
        str,
        Field(
            description='Id of the organization that owns the Object Store.',
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ]
    keys: Annotated[
        List[str],
        Field(
            description='Keys of the Object Store files.', examples=[['key1', 'key2']]
        ),
    ]


class GetObjectStoreURLRequest(BaseModel):
    organizationId: Annotated[
        str,
        Field(
            description='Id of the organization that owns the Object Store.',
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ]
    jobId: Annotated[
        str,
        Field(
            description='Id of the download job for the files.',
            examples=['2585354eb2e23cbbc4ba714332884650'],
        ),
    ]


class GetObjectStorePropertiesRequest(BaseModel):
    organizationId: Annotated[
        str,
        Field(
            description='Id of the organization that owns the Object Store.',
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ]
    key: Annotated[
        str, Field(description='Key in the Object Store.', examples=['key1'])
    ]


class GetObjectStoreResponse(BaseModel):
    jobId: Annotated[
        Optional[str],
        Field(
            description='Id of the job, which you can use to request a download URL.'
        ),
    ] = None
    url: Annotated[
        Optional[str],
        Field(
            description='The URL to download the object. This can also be null. To download the object, paste the full URL (including the URL parameters) into a browser.'
        ),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class ObjectStoreProperties(BaseModel):
    key: Annotated[Optional[str], Field(description='Object Store key.')] = None
    modified: Annotated[
        Optional[datetime], Field(description='Last time it was modified.')
    ] = None
    created: Annotated[
        Optional[datetime], Field(description='Date this project was created.')
    ] = None
    size: Annotated[
        Optional[float], Field(description='Object Store file size.', examples=[24])
    ] = None
    md5: Annotated[
        Optional[str],
        Field(description='MD5 (hashing algorithm) hash authentication code.'),
    ] = None
    mime: Annotated[Optional[str], Field(description='MIME type.')] = None
    preview: Annotated[
        Optional[str], Field(description='Preview of the Object Store file content.')
    ] = None


class GridChart(BaseModel):
    chartName: Annotated[Optional[str], Field(description='The chart name.')] = None
    width: Annotated[Optional[int], Field(description='Width of the chart.')] = None
    height: Annotated[Optional[int], Field(description='Height of the chart.')] = None
    row: Annotated[Optional[int], Field(description='Number of rows of the chart.')] = (
        None
    )
    column: Annotated[
        Optional[int], Field(description='Number of columns of the chart.')
    ] = None
    sort: Annotated[Optional[int], Field(description='Sort of the chart.')] = None


class GroupOrderManager(BaseModel):
    id: Annotated[Optional[int], Field(description='The unique order group Id.')] = None
    quantity: Annotated[
        Optional[float], Field(description='The group order quantity.')
    ] = None
    count: Annotated[
        Optional[int],
        Field(description='The total order count associated with this order group.'),
    ] = None
    limitPrice: Annotated[
        Optional[float],
        Field(description='The limit price associated with this order group if any.'),
    ] = None
    orderIds: Annotated[
        Optional[List[int]], Field(description='The order Ids in this group.')
    ] = None
    direction: Annotated[
        Optional[int], Field(description='Order Direction Property based off Quantity.')
    ] = None


class BrokerageHolding(BaseModel):
    symbolId: Annotated[
        Optional[str],
        Field(
            description='Symbol Id of the holding.',
            examples=['BTCUSD 2XR', 'SPY R735QTJ8XC9X'],
        ),
    ] = None
    symbol: Annotated[
        Optional[str],
        Field(description='Symbol ticker of the holding.', examples=['BTCUSD', 'SPY']),
    ] = None
    quantity: Annotated[
        Optional[float], Field(description='Quantity of the Symbol you hold.')
    ] = None
    averagePrice: Annotated[
        Optional[float],
        Field(
            description='Average price of your Holding in the currency the symbol is traded in.'
        ),
    ] = None


class Type1(Enum):
    price = 'price'
    volatility = 'volatility'


class Direction(Enum):
    down = 'down'
    flat = 'flat'
    up = 'up'


class Insight(BaseModel):
    id: Annotated[
        Optional[str],
        Field(
            description='Id of the insight.',
            examples=['81ff7c1daf404ee39d612df321df5931'],
        ),
    ] = None
    groupId: Annotated[
        Optional[str], Field(description='Id of the group of insights.')
    ] = None
    sourceModel: Annotated[
        Optional[str],
        Field(
            description='An identifier for the source model that generated this insight.',
            examples=['952d6ff7-e513-4971-aa50-cbe13bf56898'],
        ),
    ] = None
    generatedTime: Annotated[
        Optional[int],
        Field(
            description='Gets the Unix time this insight was generated.',
            examples=[1753714506],
        ),
    ] = None
    closeTime: Annotated[
        Optional[int],
        Field(
            description='Gets the Unix time this insight was closed.',
            examples=[1753800906],
        ),
    ] = None
    symbol: Annotated[
        Optional[str],
        Field(
            description='Gets the symbol Id this insight is for.',
            examples=['BTCUSD 2XR'],
        ),
    ] = None
    ticker: Annotated[
        Optional[str],
        Field(
            description='Gets the symbol ticker this insight is for.',
            examples=['BTCUSD'],
        ),
    ] = None
    type: Annotated[Optional[Type1], Field(description='Gets the type of insight.')] = (
        None
    )
    reference: Annotated[
        Optional[float],
        Field(
            description='Gets the initial reference value this insight is predicting against. That is, the price of the asset when the insight was created.',
            examples=[118159.19],
        ),
    ] = None
    referenceFinal: Annotated[
        Optional[float],
        Field(
            description='Gets the final reference value, used for scoring, this insight is predicting against.'
        ),
    ] = None
    direction: Annotated[
        Optional[Direction], Field(description='Gets the predicted direction.')
    ] = None
    period: Annotated[
        Optional[int],
        Field(
            description='Gets the period, in seconds, over which this insight is expected to come to fruition.'
        ),
    ] = None
    magnitude: Annotated[
        Optional[float],
        Field(
            description='Gets the predicted percent change in the insight type (price/volatility). This value can be null.'
        ),
    ] = None
    confidence: Annotated[
        Optional[float],
        Field(
            description='Gets the confidence in this insight. This value can be null.'
        ),
    ] = None
    weight: Annotated[
        Optional[float],
        Field(
            description='Gets the portfolio weight of this insight. This value can be null.'
        ),
    ] = None
    scoreFinal: Annotated[
        Optional[bool],
        Field(description="Gets whether or not this is the insight's final score."),
    ] = None
    scoreDirection: Annotated[
        Optional[float], Field(description='Gets the direction score.')
    ] = None
    scoreMagnitude: Annotated[
        Optional[float], Field(description='Gets the magnitude score.')
    ] = None
    estimatedValue: Annotated[
        Optional[float],
        Field(
            description='Gets the estimated value of this insight in the account currency.'
        ),
    ] = None
    tag: Annotated[
        Optional[str],
        Field(description="The insight's tag containing additional information."),
    ] = None


class LeanVersion(BaseModel):
    id: Annotated[Optional[int], Field(description='Id of the LEAN version.')] = None
    created: Annotated[
        Optional[datetime], Field(description='Date when this version was created.')
    ] = None
    description: Annotated[
        Optional[str], Field(description='Description of the LEAN version.')
    ] = None
    leanHash: Annotated[
        Optional[str], Field(description='Commit Hash in the LEAN repository.')
    ] = None
    leanCloudHash: Annotated[
        Optional[str], Field(description='Commit Hash in the LEAN Cloud repository.')
    ] = None
    name: Annotated[
        Optional[str], Field(description='Name of the branch where the commit is.')
    ] = None
    ref: Annotated[
        Optional[str], Field(description='Reference to the branch where the commit is.')
    ] = None
    public: Annotated[
        Optional[bool],
        Field(description='Indicates if the version is available for the public.'),
    ] = None


class Library(BaseModel):
    projectId: Annotated[
        int,
        Field(description='Project Id of the library project.', examples=[23456789]),
    ]
    libraryName: Annotated[
        Optional[str], Field(description='Name of the library project.')
    ] = None
    ownerName: Annotated[
        Optional[str], Field(description='Name of the library project owner.')
    ] = None
    access: Annotated[
        Optional[bool],
        Field(description='Indicate if the library project can be accessed.'),
    ] = None


class Status2(Enum):
    DeployError = 'DeployError'
    InQueue = 'InQueue'
    Running = 'Running'
    Stopped = 'Stopped'
    Liquidated = 'Liquidated'
    Deleted = 'Deleted'
    Completed = 'Completed'
    RuntimeError = 'RuntimeError'
    Invalid = 'Invalid'
    LoggingIn = 'LoggingIn'
    Initializing = 'Initializing'
    History = 'History'


class LiveAuthenticationData(BaseModel):
    pass


class NotifyInsights(Enum):
    true = 'true'
    false = 'false'


class NotifyOrderEvents(Enum):
    true = 'true'
    false = 'false'


class AutoRestart(Enum):
    true = 'true'
    false = 'false'


class LiveAlgorithmSummary(BaseModel):
    projectId: Annotated[Optional[int], Field(description='Id of the project.')] = None
    deployId: Annotated[
        Optional[str], Field(description='Id of the live deployment.')
    ] = None
    status: Annotated[
        Optional[str], Field(description='The current status of the deployment.')
    ] = None
    launched: Annotated[
        Optional[datetime],
        Field(description='The date and time when the deployment was launched.'),
    ] = None
    stopped: Annotated[
        Optional[datetime],
        Field(description='The date and time when the deployment was stopped.'),
    ] = None
    brokerage: Annotated[
        Optional[str], Field(description='The brokerage used for the deployment.')
    ] = None
    subscription: Annotated[
        Optional[str], Field(description="The chart to which you're subscribed.")
    ] = None
    equity: Annotated[
        Optional[float],
        Field(description='The equity value associated with the deployment.', ge=0.0),
    ] = None
    environment: Annotated[
        Optional[str],
        Field(description='The environment in which the deployment is running.'),
    ] = None
    description: Annotated[
        Optional[str], Field(description='The project description.')
    ] = None
    error: Annotated[
        Optional[str],
        Field(description='The error message if there was a runtime error.'),
    ] = None
    leagues: Annotated[
        Optional[List[str]],
        Field(description='Quant Leagues the algorithm is enrolled in.'),
    ] = None


class LiquidateLiveAlgorithmRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Project Id for the live instance to liquidate.',
            examples=[23456789],
        ),
    ]


class ListObjectStoreRequest(BaseModel):
    organizationId: Annotated[
        str,
        Field(
            description='Id of the organization to list the Object Store files from.',
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ]
    path: Annotated[
        Optional[str],
        Field(
            description='Path to a directory in the Object Store.',
            examples=['/', 'folder1/models'],
        ),
    ] = None


class ListOptimizationRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the Project to get a list of optimizations for.',
            examples=[23456789],
        ),
    ]


class LiveInsightsResponse(BaseModel):
    insights: Annotated[
        Optional[List[Insight]], Field(description='Collection of insights.')
    ] = None
    length: Annotated[
        Optional[int], Field(description='Total number of returned insights')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None


class Status4(Enum):
    loading = 'loading'


class LoadingResponse(BaseModel):
    progress: Annotated[
        Optional[float],
        Field(description='Loading percentage of the data generation process.'),
    ] = None
    status: Annotated[
        Optional[Status4], Field(description='Status of the data generation process.')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None


class Market(Enum):
    usa = 'usa'
    oanda = 'oanda'
    fxcm = 'fxcm'
    dukascopy = 'dukascopy'
    bitfinex = 'bitfinex'
    cmeglobex = 'cmeglobex'
    nymex = 'nymex'
    cbot = 'cbot'
    ice = 'ice'
    cboe = 'cboe'
    nse = 'nse'
    comex = 'comex'
    cme = 'cme'
    sgx = 'sgx'
    hkfe = 'hkfe'
    coinbase = 'coinbase'
    kraken = 'kraken'
    bitstamp = 'bitstamp'
    okcoin = 'okcoin'
    bithumb = 'bithumb'
    binance = 'binance'
    poloniex = 'poloniex'
    coinone = 'coinone'
    hitbtc = 'hitbtc'
    bittrex = 'bittrex'


class ObjectStoreBinaryFile(BaseModel):
    organizationId: Annotated[
        str,
        Field(
            description='Orgainization ID.',
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ]
    key: Annotated[
        str,
        Field(
            description='Unique key to access the object in Object Store.',
            examples=['key1'],
        ),
    ]
    objectData: Annotated[bytes, Field(description='Object data to be stored.')]


class ObjectStoreSummary(BaseModel):
    key: Annotated[
        Optional[str], Field(description='Object Store key.', examples=['Mia/Test'])
    ] = None
    name: Annotated[Optional[str], Field(description='File or folder name.')] = None
    modified: Annotated[
        Optional[datetime], Field(description='Last time it was modified.')
    ] = None
    mime: Annotated[
        Optional[str],
        Field(description='MIME type.', examples=['application/json', 'directory']),
    ] = None
    folder: Annotated[
        Optional[bool], Field(description='True if it is a folder, false otherwise.')
    ] = None
    size: Annotated[
        Optional[float], Field(description='Object Store file size.', examples=[13])
    ] = None


class Operator(Enum):
    LessOrEqual = 'LessOrEqual'
    Less = 'Less'
    GreaterOrEqual = 'GreaterOrEqual'
    Greater = 'Greater'
    NotEqual = 'NotEqual'
    Equals = 'Equals'


class OptimizationConstraint(BaseModel):
    target: Annotated[
        OptimizationTargetStatistic, Field(description='The target statistic to track.')
    ]
    operator: Annotated[Operator, Field(description='The target comparison operation.')]
    targetValue: Annotated[
        float,
        Field(
            description='The threshold value for the target constraint.', examples=[1]
        ),
    ]


class OptimizationParameter(BaseModel):
    name: Annotated[
        str,
        Field(description='Name of optimization parameter.', examples=['rsi_period']),
    ]
    min: Annotated[
        float,
        Field(
            description='Minimum value of optimization parameter, applicable for boundary conditions.',
            examples=[10],
        ),
    ]
    max: Annotated[
        float,
        Field(
            description='Maximum value of optimization parameter, applicable for boundary conditions.',
            examples=[20],
        ),
    ]
    step: Annotated[
        float, Field(description='Movement, should be positive.', examples=[1])
    ]
    minStep: Annotated[
        Optional[float],
        Field(
            description='Minimal possible movement for current parameter, should be positive. Used by <code>Strategies.EulerSearchOptimizationStrategy</code> to determine when this parameter can no longer be optimized.',
            examples=[1],
        ),
    ] = None


class OptimizationTarget(BaseModel):
    target: Annotated[
        Optional[OptimizationTargetStatistic],
        Field(description='The target statistic to track.'),
    ] = None
    extremum: Annotated[
        Optional[OptimizationTargetTo],
        Field(description='Defines the direction of optimization.'),
    ] = None
    targetValue: Annotated[
        Optional[float],
        Field(
            description='Desired value for the optimization target statistic.',
            examples=[1],
        ),
    ] = None


class NodePrices(BaseModel):
    monthly: Annotated[
        Optional[int], Field(description='The monthly price of the node in US dollars.')
    ] = None
    yearly: Annotated[
        Optional[int], Field(description='The yearly price of the node in US dollars.')
    ] = None


class OptimizationNodeType(Enum):
    O2_8 = 'O2-8'
    O4_12 = 'O4-12'
    O8_16 = 'O8-16'


class OptimizationStatus(Enum):
    new = 'new'
    aborted = 'aborted'
    running = 'running'
    completed = 'completed'


class OptimizationRuntimeStatistics(BaseModel):
    Completed: Annotated[
        Optional[str],
        Field(description='Number of completed backtests in the optimization job.'),
    ] = None
    Failed: Annotated[
        Optional[str],
        Field(description='Number of failed backtests in the optimization job.'),
    ] = None
    Running: Annotated[
        Optional[str],
        Field(description='Number of running backtests in the optimization job.'),
    ] = None
    In_Queue: Annotated[
        Optional[str],
        Field(
            alias='In Queue',
            description='Number of backtests waiting in-queue in the optimization job.',
        ),
    ] = None
    Average_Length: Annotated[
        Optional[time],
        Field(
            alias='Average Length',
            description='The average time of each backtest in the optimization job (HH:MM:SS).',
        ),
    ] = None
    Total_Runtime: Annotated[
        Optional[time],
        Field(
            alias='Total Runtime',
            description='The total runtime of the optimization (HH:MM:SS).',
        ),
    ] = None
    Total: Annotated[
        Optional[str], Field(description='Number of backtests in the optimization job.')
    ] = None
    Consumed: Annotated[
        Optional[str],
        Field(
            description='Amount of QuantConnect Credit consumed by the optimization job.'
        ),
    ] = None


class Type2(Enum):
    integer_0 = 0
    integer_1 = 1
    integer_2 = 2
    integer_3 = 3
    integer_4 = 4
    integer_5 = 5
    integer_6 = 6
    integer_7 = 7
    integer_8 = 8
    integer_9 = 9
    integer_10 = 10
    integer_11 = 11


class Status5(Enum):
    integer_0 = 0
    integer_1 = 1
    integer_2 = 2
    integer_3 = 3
    integer_5 = 5
    integer_6 = 6
    integer_7 = 7
    integer_8 = 8
    integer_9 = 9


class SecurityType(Enum):
    integer_0 = 0
    integer_1 = 1
    integer_2 = 2
    integer_3 = 3
    integer_4 = 4
    integer_5 = 5
    integer_6 = 6
    integer_7 = 7


class Direction1(Enum):
    integer_0 = 0
    integer_1 = 1
    integer_2 = 2


class OrderProperties(BaseModel):
    timeInForce: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='Defines the length of time over which an order will continue working before it is cancelled.'
        ),
    ] = None


class OrderDirection(Enum):
    buy = 'buy'
    sell = 'sell'
    hold = 'hold'


class Status6(Enum):
    new = 'new'
    submitted = 'submitted'
    partiallyFilled = 'partiallyFilled'
    filled = 'filled'
    canceled = 'canceled'
    none = 'none'
    invalid = 'invalid'
    cancelPending = 'cancelPending'
    updateSubmitted = 'updateSubmitted'


class OrderEvent(BaseModel):
    algorithmId: Annotated[
        Optional[str], Field(description='Algorithm Id, BacktestId or DeployId.')
    ] = None
    symbol: Annotated[
        Optional[str],
        Field(
            description='Easy access to the order symbol associated with this event.'
        ),
    ] = None
    symbolValue: Annotated[
        Optional[str],
        Field(
            description='The current symbol for this ticker; It is a user friendly symbol representation.'
        ),
    ] = None
    symbolPermtick: Annotated[
        Optional[str],
        Field(description='The original symbol used to generate this symbol.'),
    ] = None
    orderId: Annotated[
        Optional[int], Field(description='Id of the order this event comes from.')
    ] = None
    orderEventId: Annotated[
        Optional[int], Field(description='The unique order event id for each order.')
    ] = None
    id: Annotated[
        Optional[str], Field(description='The unique order event Id for each order.')
    ] = None
    status: Annotated[Optional[Status6], Field(description='Status of the Order.')] = (
        None
    )
    orderFeeAmount: Annotated[
        Optional[float], Field(description='The fee amount associated with the order.')
    ] = None
    orderFeeCurrency: Annotated[
        Optional[str], Field(description='The fee currency associated with the order.')
    ] = None
    fillPrice: Annotated[
        Optional[float], Field(description='Fill price information about the order.')
    ] = None
    fillPriceCurrency: Annotated[
        Optional[str], Field(description='Currency for the fill price.')
    ] = None
    fillQuantity: Annotated[
        Optional[float],
        Field(
            description='Number of shares of the order that was filled in this event.'
        ),
    ] = None
    direction: Annotated[
        Optional[OrderDirection], Field(description='Order direction.')
    ] = None
    message: Annotated[
        Optional[str], Field(description='Any message from the exchange.')
    ] = None
    isAssignment: Annotated[
        Optional[bool], Field(description='True if the order event is an assignment.')
    ] = None
    stopPrice: Annotated[
        Optional[float], Field(description='The current stop price.')
    ] = None
    limitPrice: Annotated[
        Optional[float], Field(description='The current limit price.')
    ] = None
    quantity: Annotated[
        Optional[float], Field(description='The current order quantity.')
    ] = None
    time: Annotated[
        Optional[float], Field(description='The time of this event in unix timestamp.')
    ] = None
    isInTheMoney: Annotated[
        Optional[bool],
        Field(description="True if the order event's option is In-The-Money (ITM)."),
    ] = None


class OrderSubmissionData(BaseModel):
    bidPrice: Annotated[
        Optional[float], Field(description='The bid price at order submission time.')
    ] = None
    askPrice: Annotated[
        Optional[float], Field(description='The ask price at order submission time.')
    ] = None
    lastPrice: Annotated[
        Optional[float],
        Field(description='The current price at order submission time.'),
    ] = None


class Holding(BaseModel):
    a: Annotated[
        Optional[float],
        Field(
            description='Average purchase price of the holding in the currency it trades in.'
        ),
    ] = None
    q: Annotated[Optional[float], Field(description='Quantity of the asset.')] = None
    p: Annotated[
        Optional[float],
        Field(
            description='Current market price of the asset in the currency it trades in.'
        ),
    ] = None
    v: Annotated[
        Optional[float], Field(description='Current market value of the holding.')
    ] = None
    u: Annotated[
        Optional[float], Field(description='Unrealized profit/loss of the position.')
    ] = None
    up: Annotated[
        Optional[float],
        Field(description='Unrealized profit/loss percentage of the position.'),
    ] = None


class ProjectFile(BaseModel):
    id: Annotated[
        Optional[int],
        Field(description='ID of the project file. This can also be null.'),
    ] = None
    projectId: Annotated[
        Optional[int], Field(description='ID of the project.', examples=[23456789])
    ] = None
    name: Annotated[Optional[str], Field(description='Name of a project file.')] = None
    content: Annotated[
        Optional[str], Field(description='Contents of the project file.')
    ] = None
    modified: Annotated[
        Optional[datetime], Field(description='DateTime project file was modified.')
    ] = None
    open: Annotated[
        Optional[bool],
        Field(description='Indicates if the project file is open or not.'),
    ] = None
    isLibrary: Annotated[
        Optional[bool],
        Field(
            description="Indicates if the project file is a library or not. It's always false in live/read and backtest/read."
        ),
    ] = None


class ProjectFilesResponse(BaseModel):
    files: Annotated[
        Optional[List[ProjectFile]],
        Field(description='List of project file information.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class File(BaseModel):
    name: Annotated[
        Optional[str],
        Field(description='Name of a file.', examples=['main.py', 'Main.cs']),
    ] = None
    content: Annotated[Optional[str], Field(description='Contents of the file.')] = None


class Error(BaseModel):
    message: Annotated[str, Field(description='Error message.')]
    stacktrace: Annotated[
        Optional[str], Field(description='Stack trace of the error.')
    ] = None


class PortfolioStatistics(BaseModel):
    averageWinRate: Annotated[
        Optional[float],
        Field(description='The average rate of return for winning trades.'),
    ] = None
    averageLossRate: Annotated[
        Optional[float],
        Field(description='The average rate of return for losing trades.'),
    ] = None
    profitLossRatio: Annotated[
        Optional[float],
        Field(
            description='The ratio of the average win rate to the average loss rate.'
        ),
    ] = None
    winRate: Annotated[
        Optional[float],
        Field(
            description='The ratio of the number of winning trades to the total number of trades.'
        ),
    ] = None
    lossRate: Annotated[
        Optional[float],
        Field(
            description='The ratio of the number of losing trades to the total number of trades.'
        ),
    ] = None
    expectancy: Annotated[
        Optional[float], Field(description='The expected value of the rate of return.')
    ] = None
    startEquity: Annotated[
        Optional[float], Field(description='Initial Equity Total Value.')
    ] = None
    endEquity: Annotated[
        Optional[float], Field(description='Final Equity Total Value')
    ] = None
    compoundingAnnualReturn: Annotated[
        Optional[float],
        Field(
            description='Annual compounded returns statistic based on the final-starting capital and years.'
        ),
    ] = None
    drawdown: Annotated[
        Optional[float], Field(description='Drawdown maximum percentage.')
    ] = None
    totalNetProfit: Annotated[
        Optional[float], Field(description='The total net profit percentage.')
    ] = None
    sharpeRatio: Annotated[
        Optional[float],
        Field(
            description='Sharpe ratio with respect to risk free rate: measures excess of return per unit of risk.'
        ),
    ] = None
    probabilisticSharpeRatio: Annotated[
        Optional[float],
        Field(
            description='Probabilistic Sharpe Ratio is a probability measure associated with the Sharpe ratio. It informs us of the probability that the estimated Sharpe ratio is greater than a chosen benchmark.'
        ),
    ] = None
    sortinoRatio: Annotated[
        Optional[float],
        Field(
            description='Sortino ratio with respect to risk free rate; measures excess of return per unit of downside risk.'
        ),
    ] = None
    alpha: Annotated[
        Optional[float],
        Field(
            description='Algorithm "Alpha" statistic - abnormal returns over the risk free rate and the relationshio (beta) with the benchmark returns.'
        ),
    ] = None
    beta: Annotated[
        Optional[float],
        Field(
            description='Algorithm beta statistic - the covariance between the algorithm and benchmark performance, divided by benchmark variance.'
        ),
    ] = None
    annualStandardDeviation: Annotated[
        Optional[float], Field(description='Annualized standard deviation')
    ] = None
    annualVariance: Annotated[
        Optional[float],
        Field(
            description='Annualized variance statistic calculation using the daily performance variance and trading days per year.'
        ),
    ] = None
    informationRatio: Annotated[
        Optional[float], Field(description='Information ratio - risk adjusted return.')
    ] = None
    trackingError: Annotated[
        Optional[float],
        Field(
            description='Tracking error volatility (TEV) statistic - a measure of how closely a portfolio follows the index to which it is benchmarked.'
        ),
    ] = None
    treynorRatio: Annotated[
        Optional[float],
        Field(
            description='Treynor ratio statistic is a measurement of the returns earned in excess of that which could have been earned on an investment that has no diversifiable risk.'
        ),
    ] = None
    portfolioTurnover: Annotated[
        Optional[float], Field(description='The average Portfolio Turnover.')
    ] = None
    valueAtRisk99: Annotated[
        Optional[float],
        Field(
            description='The 1-day VaR for the portfolio, using the Variance-covariance approach. Assumes a 99% confidence level, 1 year lookback period, and that the returns are normally distributed.'
        ),
    ] = None
    valueAtRisk95: Annotated[
        Optional[float],
        Field(
            description='The 1-day VaR for the portfolio, using the Variance-covariance approach. Assumes a 95% confidence level, 1 year lookback period, and that the returns are normally distributed.'
        ),
    ] = None


class ReadFilesRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project that contains the file.', examples=[23456789]
        ),
    ]
    name: Annotated[
        Optional[str],
        Field(
            description='The name of the file to read.', examples=['file.py', 'File.cs']
        ),
    ] = None
    codeSourceId: Annotated[
        Optional[str],
        Field(
            description="Name of the environment that's creating the request.",
            examples=['MCP Server'],
        ),
    ] = None


class ReadCompileRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project you requested to compile.',
            examples=[23456789],
        ),
    ]
    compileId: Annotated[
        str,
        Field(
            description='Compile Id returned during the creation request.',
            examples=[
                '5d1f2cba3a0ec7407c566614300502b5-173e0419674daf4144ce7c9931155ca8'
            ],
        ),
    ]


class ReadLiveLogsRequest(BaseModel):
    format: Annotated[
        Optional[Any],
        Field(description='Format of the log results.', examples=['json']),
    ] = None
    projectId: Annotated[
        int,
        Field(
            description='Id of the project that contains the live running algorithm.',
            examples=[23456789],
        ),
    ]
    algorithmId: Annotated[
        str,
        Field(
            description='Deploy Id (Algorithm Id) of the live running algorithm.',
            examples=['L-6e9d8a78f5af89d401f630585be90e43'],
        ),
    ]
    startLine: Annotated[
        int,
        Field(
            description='Start line (inclusive) of logs to read. The lines numbers start at 0.'
        ),
    ]
    endLine: Annotated[
        int,
        Field(
            description='End line (exclusive) of logs to read, where endLine - startLine <= 250.'
        ),
    ]


class ReadLiveLogsResponse(BaseModel):
    logs: Annotated[
        Optional[List[str]], Field(description='List of logs from the live algorithm.')
    ] = None
    length: Annotated[
        Optional[int],
        Field(
            description='Total amount of rows in the logs across all live deployments for this project.'
        ),
    ] = None
    deploymentOffset: Annotated[
        Optional[int],
        Field(
            description='Number of log rows before the given deployment (the `algorithmId` in the request).'
        ),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class ReadProjectRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project. If not provided the API will return a details list of all projects.',
            examples=[23456789],
        ),
    ]


class ReadProjectNodesRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project to which the nodes refer.',
            examples=[23456789],
        ),
    ]


class ReadLiveAlgorithmRequest(BaseModel):
    projectId: Annotated[
        int, Field(description='Id of the project to read.', examples=[23456789])
    ]


class ReadLivePortfolioRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project from which to read the live algorithm.',
            examples=[23456789],
        ),
    ]


class ReadLiveOrdersRequest(BaseModel):
    start: Annotated[
        int,
        Field(description='Starting index of the orders to be fetched.', examples=[0]),
    ]
    end: Annotated[
        int,
        Field(
            description='Last index of the orders to be fetched. Note that end - start must be <= 1,000.',
            examples=[100],
        ),
    ]
    projectId: Annotated[
        int,
        Field(
            description='Id of the project from which to read the live algorithm.',
            examples=[23456789],
        ),
    ]


class ReadLiveInsightsRequest(BaseModel):
    start: Annotated[
        Optional[int],
        Field(
            description='Starting index of the insights to be fetched. Required if end > 100.',
            examples=[0],
        ),
    ] = None
    end: Annotated[
        int,
        Field(
            description='Last index of the insights to be fetched. Note that end - start must be less than 100.',
            examples=[100],
        ),
    ]
    projectId: Annotated[
        int,
        Field(
            description='Id of the project from which to read the live algorithm.',
            examples=[23456789],
        ),
    ]


class Status7(Enum):
    Running = 'Running'
    Stopped = 'Stopped'
    RuntimeError = 'RuntimeError'
    Liquidated = 'Liquidated'


class ListLiveAlgorithmsRequest(BaseModel):
    status: Annotated[
        Optional[Status7],
        Field(description='Status of the live algorithms to include in the response.'),
    ] = None


class ReadBacktestRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project that contains the backtest.',
            examples=[23456789],
        ),
    ]
    backtestId: Annotated[
        str,
        Field(
            description='Id of the backtest to read.',
            examples=['26c7bb06b8487cff1c7b3c44652b30f1'],
        ),
    ]


class ListBacktestRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project from which to read one or multiple backtests.',
            examples=[23456789],
        ),
    ]
    includeStatistics: Annotated[
        Optional[bool],
        Field(
            description='If true, the backtests summaries from the response will contain the statistics with their corresponding values.',
            examples=[True],
        ),
    ] = False


class ReadBacktestChartRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project that contains the backtest.',
            examples=[12345678],
        ),
    ]
    backtestId: Annotated[
        str,
        Field(
            description='Id of the backtest for this chart request.',
            examples=['2a748c241eb93b0b57b4747b3dacc80e'],
        ),
    ]
    name: Annotated[
        str,
        Field(description='The requested chart name.', examples=['Strategy Equity']),
    ]
    count: Annotated[
        int, Field(description='The number of data points to request.', examples=[100])
    ]
    start: Annotated[
        int,
        Field(
            description='The start timestamp of the request in Unix time.',
            examples=[1717801200],
        ),
    ]
    end: Annotated[
        int,
        Field(
            description='The end timestamp of the request in Unix time.',
            examples=[1743462000],
        ),
    ]


class ReadBacktestOrdersRequest(BaseModel):
    start: Annotated[
        int,
        Field(description='Starting index of the orders to be fetched.', examples=[0]),
    ]
    end: Annotated[
        int,
        Field(
            description='Last index of the orders to be fetched. Note that end - start must be less than 100.',
            examples=[100],
        ),
    ]
    projectId: Annotated[
        int,
        Field(
            description='Id of the project from which to read the backtest.',
            examples=[23456789],
        ),
    ]
    backtestId: Annotated[
        str,
        Field(
            description='Id of the backtest from which to read the orders.',
            examples=['26c7bb06b8487cff1c7b3c44652b30f1'],
        ),
    ]


class ReadBacktestInsightsRequest(BaseModel):
    start: Annotated[
        int,
        Field(
            description='Starting index of the insights to be fetched.', examples=[0]
        ),
    ]
    end: Annotated[
        int,
        Field(
            description='Last index of the insights to be fetched. Note that end - start must be less than 100.',
            examples=[100],
        ),
    ]
    projectId: Annotated[
        int,
        Field(
            description='Id of the project from which to read the backtest.',
            examples=[23456789],
        ),
    ]
    backtestId: Annotated[
        str,
        Field(
            description='Id of the backtest from which to read the insights.',
            examples=['26c7bb06b8487cff1c7b3c44652b30f1'],
        ),
    ]


class ReadLiveChartRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description="Id of the project that's live trading.", examples=[23456789]
        ),
    ]
    name: Annotated[
        str,
        Field(description='Name of the chart to read.', examples=['Strategy Equity']),
    ]
    count: Annotated[
        int, Field(description='The number of data points to request.', examples=[100])
    ]
    start: Annotated[
        int,
        Field(description='The unix start time of the request.', examples=[1717801200]),
    ]
    end: Annotated[
        int,
        Field(description='The unix end time of the request.', examples=[1743462000]),
    ]


class ReadOptimizationRequest(BaseModel):
    optimizationId: Annotated[
        str,
        Field(
            description='Id of the optimization to read.',
            examples=['O-401d3d40b5a0e9f8c46c954a303f3ddd'],
        ),
    ]


class ResearchGuide(BaseModel):
    minutes: Annotated[
        Optional[int],
        Field(description='Number of minutes used in developing the current backtest.'),
    ] = None
    backtestCount: Annotated[
        Optional[int],
        Field(description='The quantity of backtests run in the project.'),
    ] = None
    parameters: Annotated[
        Optional[int], Field(description='Number of parameters detected.')
    ] = None


class RestResponse(BaseModel):
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class Resolution(Enum):
    Tick = 'Tick'
    Second = 'Second'
    Minute = 'Minute'
    Hour = 'Hour'
    Daily = 'Daily'


class RuntimeStatistics(BaseModel):
    Equity: Annotated[
        Optional[str], Field(description='Total portfolio value.', examples=['$100.00'])
    ] = None
    Fees: Annotated[
        Optional[str], Field(description='Transaction fee.', examples=['-$100.00'])
    ] = None
    Holdings: Annotated[
        Optional[str],
        Field(description='Equity value of security holdings.', examples=['$100.00']),
    ] = None
    Net_Profit: Annotated[
        Optional[str],
        Field(alias='Net Profit', description='Net profit.', examples=['$100.00']),
    ] = None
    Probabilistic_Sharpe_Ratio: Annotated[
        Optional[str],
        Field(
            alias='Probabilistic Sharpe Ratio',
            description='Probabilistic Sharpe Ratio.',
            examples=['50.00%'],
        ),
    ] = None
    Return: Annotated[
        Optional[str], Field(description='Return.', examples=['50.00%'])
    ] = None
    Unrealized: Annotated[
        Optional[str],
        Field(description='Unrealized profit/loss.', examples=['$100.00']),
    ] = None
    Volume: Annotated[
        Optional[str],
        Field(description='Total transaction volume.', examples=['$100.00']),
    ] = None


class ChartResolution(Enum):
    field_10minute = '10minute'
    minute = 'minute'
    second = 'second'


class SeriesType(Enum):
    integer_0 = 0
    integer_1 = 1
    integer_2 = 2
    integer_3 = 3
    integer_4 = 4
    integer_5 = 5
    integer_6 = 6
    integer_7 = 7
    integer_9 = 9
    integer_19 = 19


class ScatterMarkerSymbol(Enum):
    none = 'none'
    circle = 'circle'
    square = 'square'
    diamond = 'diamond'
    triangle = 'triangle'
    triangle_down = 'triangle-down'


class Series(BaseModel):
    name: Annotated[Optional[str], Field(description='Name of the series.')] = None
    unit: Annotated[Optional[str], Field(description='Axis for the chart series.')] = (
        None
    )
    index: Annotated[
        Optional[int], Field(description='Index/position of the series on the chart.')
    ] = None
    values: Annotated[
        Optional[List[List]],
        Field(
            description='Values for the series plot. These values are assumed to be in ascending time order (first points earliest, last points latest)'
        ),
    ] = None
    seriesType: Annotated[
        Optional[SeriesType],
        Field(
            description='Chart type for the series. 0=Line, 1=Scatter, 2=Candle, 3=Bar, 4=Flag, 5=StackedArea, 6=Pie, 7=Treemap, 9=Heatmap, 10=Scatter3d.'
        ),
    ] = None
    color: Annotated[Optional[str], Field(description='Color of the series.')] = None
    scatterMarkerSymbol: Annotated[
        Optional[ScatterMarkerSymbol],
        Field(description='Shape or symbol for the marker in a scatter plot.'),
    ] = None


class SetObjectStoreRequest(BaseModel):
    organizationId: Annotated[
        Optional[str],
        Field(
            description="Organization ID we'd like to upload the file to.",
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ] = None
    key: Annotated[
        Optional[str], Field(description='Key to the Object Store file.')
    ] = None


class StatisticsResult(BaseModel):
    Total_Orders: Annotated[
        Optional[str], Field(alias='Total Orders', description='Total nuber of orders.')
    ] = None
    Average_Win: Annotated[
        Optional[str],
        Field(
            alias='Average Win',
            description='The average rate of return for winning trades.',
        ),
    ] = None
    Average_Loss: Annotated[
        Optional[str],
        Field(
            alias='Average Loss',
            description='The average rate of return for losing trades.',
        ),
    ] = None
    Compounding_Annual_Return: Annotated[
        Optional[str],
        Field(
            alias='Compounding Annual Return',
            description='Annual compounded returns statistic based on the final-starting capital and years.',
        ),
    ] = None
    Drawdown: Annotated[
        Optional[str], Field(description='Drawdown maximum percentage.')
    ] = None
    Expectancy: Annotated[
        Optional[str], Field(description='The expected value of the rate of return.')
    ] = None
    Start_Equity: Annotated[
        Optional[str],
        Field(alias='Start Equity', description='Initial Equity Total Value.'),
    ] = None
    End_Equity: Annotated[
        Optional[str],
        Field(alias='End Equity', description='Final Equity Total Value.'),
    ] = None
    Net_Profit: Annotated[
        Optional[str],
        Field(alias='Net Profit', description='The total net profit percentage.'),
    ] = None
    Sharpe_Ratio: Annotated[
        Optional[str],
        Field(
            alias='Sharpe Ratio',
            description='Sharpe ratio with respect to risk free rate; measures excess of return per unit of risk.',
        ),
    ] = None
    Sortino_Ratio: Annotated[
        Optional[str],
        Field(
            alias='Sortino Ratio',
            description='Sortino ratio with respect to risk free rate; measures excess of return per unit of downside risk.',
        ),
    ] = None
    Probabilistic_Sharpe_Ratio: Annotated[
        Optional[str],
        Field(
            alias='Probabilistic Sharpe Ratio',
            description='Is a probability measure associated with the Sharpe ratio. It informs us of the probability that the estimated Sharpe ratio is greater than a chosen benchmark.',
        ),
    ] = None
    Loss_Rate: Annotated[
        Optional[str],
        Field(
            alias='Loss Rate',
            description='The ratio of the number of losing trades to the total number of trades.',
        ),
    ] = None
    Win_Rate: Annotated[
        Optional[str],
        Field(
            alias='Win Rate',
            description='The ratio of the number of winning trades to the total number of trades.',
        ),
    ] = None
    Profit_Loss_Ratio: Annotated[
        Optional[str],
        Field(
            alias='Profit-Loss Ratio',
            description='The ratio of the average win rate to the average loss rate.',
        ),
    ] = None
    Alpha: Annotated[
        Optional[str],
        Field(
            description='Algorithm "Alpha" statistic - abnormal returns over the risk free rate and the relationshio (beta) with the benchmark returns.'
        ),
    ] = None
    Beta: Annotated[
        Optional[str],
        Field(
            description='Algorithm "beta" statistic - the covariance between the algorithm and benchmark performance, divided by benchmark\'s variance.'
        ),
    ] = None
    Annual_Standard_Deviation: Annotated[
        Optional[str],
        Field(
            alias='Annual Standard Deviation',
            description='Annualized standard deviation.',
        ),
    ] = None
    Annual_Variance: Annotated[
        Optional[str],
        Field(
            alias='Annual Variance',
            description='Annualized variance statistic calculation using the daily performance variance and trading days per year.',
        ),
    ] = None
    Information_Ratio: Annotated[
        Optional[str],
        Field(
            alias='Information Ratio',
            description='Information ratio - risk adjusted return.',
        ),
    ] = None
    Tracking_Error: Annotated[
        Optional[str],
        Field(
            alias='Tracking Error',
            description='Tracking error volatility (TEV) statistic - a measure of how closely a portfolio follows the index to which it is benchmarked.',
        ),
    ] = None
    Treynor_Ratio: Annotated[
        Optional[str],
        Field(
            alias='Treynor Ratio',
            description='Treynor ratio statistic is a measurement of the returns earned in excess of that which could have been earned on an investment that has no diversifiable risk.',
        ),
    ] = None
    Total_Fees: Annotated[
        Optional[str], Field(alias='Total Fees', description='Total amount of fees.')
    ] = None
    Estimated_Strategy_Capacity: Annotated[
        Optional[str],
        Field(
            alias='Estimated Strategy Capacity',
            description='The estimated total capacity of the strategy at a point in time.',
        ),
    ] = None
    Lowest_Capacity_Asset: Annotated[
        Optional[str],
        Field(
            alias='Lowest Capacity Asset',
            description='Provide a reference to the lowest capacity symbol used in scaling down the capacity for debugging.',
        ),
    ] = None
    Portfolio_Turnover: Annotated[
        Optional[str],
        Field(alias='Portfolio Turnover', description='The average Portfolio Turnover'),
    ] = None


class StopLiveAlgorithmRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project to stop trading live.', examples=[23456789]
        ),
    ]


class Symbol(BaseModel):
    value: Annotated[
        Optional[str], Field(description='The current symbol for this ticker.')
    ] = None
    id: Annotated[
        Optional[str], Field(description='The security identifier for this symbol.')
    ] = None
    permtick: Annotated[
        Optional[str], Field(description='The ticker at IPO for this security.')
    ] = None


class Direction2(Enum):
    integer_0 = 0
    integer_1 = 1


class Trade(BaseModel):
    symbol: Optional[Symbol] = None
    entryTime: Annotated[
        Optional[datetime], Field(description='The date and time the trade was opened.')
    ] = None
    entryPrice: Annotated[
        Optional[float],
        Field(
            description='The price at which the trade was opened (or the average price if multiple entries).'
        ),
    ] = None
    direction: Annotated[
        Optional[Direction2],
        Field(description='Direction of a trade. 0=Long, 1=Short.'),
    ] = None
    quantity: Annotated[
        Optional[float], Field(description='The total unsigned quantity of the trade.')
    ] = None
    exitTime: Annotated[
        Optional[datetime], Field(description='The date and time the trade was closed.')
    ] = None
    exitPrice: Annotated[
        Optional[float],
        Field(
            description='The price at which the trade was closed (or the average price if multiple exits).'
        ),
    ] = None
    profitLoss: Annotated[
        Optional[float],
        Field(description='The gross profit/loss of the trade (as account currency).'),
    ] = None
    totalFees: Annotated[
        Optional[float],
        Field(
            description='The total fees associated with the trade (always positive value) (as account currency).'
        ),
    ] = None
    mae: Annotated[
        Optional[float],
        Field(description='The Maximum Adverse Excursion (as account currency).'),
    ] = None
    mfe: Annotated[
        Optional[float],
        Field(description='The Maximum Favorable Excursion (as account currency).'),
    ] = None
    duration: Annotated[
        Optional[str], Field(description='The duration of the trade.')
    ] = None
    endTradeDrawdown: Annotated[
        Optional[float],
        Field(
            description='The amount of profit given back before the trade was closed.'
        ),
    ] = None


class TradeStatistics(BaseModel):
    startDateTime: Annotated[
        Optional[datetime], Field(description='The entry date/time of the first trade')
    ] = None
    endDateTime: Annotated[
        Optional[datetime], Field(description='The exit date/time of the first trade.')
    ] = None
    totalNumberOfTrades: Annotated[
        Optional[int], Field(description='The total number of trades.')
    ] = None
    numberOfWinningTrades: Annotated[
        Optional[int], Field(description='The total number of winning trades.')
    ] = None
    numberOfLosingTrades: Annotated[
        Optional[int], Field(description='The total number of losing trades.')
    ] = None
    totalProfitLoss: Annotated[
        Optional[float],
        Field(description='The total profit/loss for all trades (as symbol currency).'),
    ] = None
    totalProfit: Annotated[
        Optional[float],
        Field(
            description='The total profit for all winning trades (as symbol currency).'
        ),
    ] = None
    totalLoss: Annotated[
        Optional[float],
        Field(description='The total loss for all losing trades (as symbol currency).'),
    ] = None
    largestProfit: Annotated[
        Optional[float],
        Field(description='The largest profit in a single trade (as symbol currency).'),
    ] = None
    largestLoss: Annotated[
        Optional[float],
        Field(description='The largest loss in a single trade (as symbol currency).'),
    ] = None
    averageProfitLoss: Annotated[
        Optional[float],
        Field(
            description='The average profit/loss (a.k.a. Expectancy or Average Trade) for all trades (as symbol currency).'
        ),
    ] = None
    averageProfit: Annotated[
        Optional[float],
        Field(
            description='The average profit for all winning trades (as symbol currency).'
        ),
    ] = None
    averageLoss: Annotated[
        Optional[float],
        Field(
            description='The average loss for all winning trades (as symbol currency).'
        ),
    ] = None
    averageTradeDuration: Annotated[
        Optional[str], Field(description='The average duration for all trades.')
    ] = None
    averageWinningTradeDuration: Annotated[
        Optional[str], Field(description='The average duration for all winning trades.')
    ] = None
    averageLosingTradeDuration: Annotated[
        Optional[str], Field(description='The average duration for all losing trades.')
    ] = None
    medianTradeDuration: Annotated[
        Optional[str], Field(description='The median duration for all trades.')
    ] = None
    medianWinningTradeDuration: Annotated[
        Optional[str], Field(description='The median duration for all winning trades.')
    ] = None
    medianLosingTradeDuration: Annotated[
        Optional[str], Field(description='The median duration for all losing trades.')
    ] = None
    maxConsecutiveWinningTrades: Annotated[
        Optional[int],
        Field(description='The maximum number of consecutive winning trades.'),
    ] = None
    maxConsecutiveLosingTrades: Annotated[
        Optional[int],
        Field(description='The maximum number of consecutive losing trades.'),
    ] = None
    profitLossRatio: Annotated[
        Optional[float],
        Field(
            description='The ratio of the average profit per trade to the average loss per trade.'
        ),
    ] = None
    winLossRatio: Annotated[
        Optional[float],
        Field(
            description='The ratio of the number of winning trades to the number of losing trades.'
        ),
    ] = None
    winRate: Annotated[
        Optional[float],
        Field(
            description='The ratio of the number of winning trades to the total number of trades.'
        ),
    ] = None
    lossRate: Annotated[
        Optional[float],
        Field(
            description='The ratio of the number of losing trades to the total number of trades.'
        ),
    ] = None
    averageMAE: Annotated[
        Optional[float],
        Field(description='The average Maximum Adverse Excursion for all trades.'),
    ] = None
    averageMFE: Annotated[
        Optional[float],
        Field(description='The average Maximum Adverse Excursion for all trades.'),
    ] = None
    largestMAE: Annotated[
        Optional[float],
        Field(description='The average Maximum Favorable Excursion for all trades.'),
    ] = None
    largestMFE: Annotated[
        Optional[float],
        Field(
            description='The largest Maximum Adverse Excursion in a single trade (as symbol currency).'
        ),
    ] = None
    maximumClosedTradeDrawdown: Annotated[
        Optional[float],
        Field(
            description='The maximum closed-trade drawdown for all trades (as symbol currency).'
        ),
    ] = None
    maximumIntraTradeDrawdown: Annotated[
        Optional[float],
        Field(
            description='The maximum intra-trade drawdown for all trades (as symbol currency).'
        ),
    ] = None
    profitLossStandardDeviation: Annotated[
        Optional[float],
        Field(
            description='The standard deviation of the profits/losses for all trades (as symbol currency).'
        ),
    ] = None
    profitLossDownsideDeviation: Annotated[
        Optional[float],
        Field(
            description='The downside deviation of the profits/losses for all trades (as symbol currency).'
        ),
    ] = None
    profitFactor: Annotated[
        Optional[float],
        Field(description='The ratio of the total profit to the total loss.'),
    ] = None
    sharpeRatio: Annotated[
        Optional[float],
        Field(
            description='The ratio of the average profit/loss to the standard deviation.'
        ),
    ] = None
    sortinoRatio: Annotated[
        Optional[float],
        Field(
            description='The ratio of the average profit/loss to the downside deviation.'
        ),
    ] = None
    profitToMaxDrawdownRatio: Annotated[
        Optional[float],
        Field(
            description='The ratio of the total profit/loss to the maximum closed trade drawdown.'
        ),
    ] = None
    maximumEndTradeDrawdown: Annotated[
        Optional[float],
        Field(
            description='The maximum amount of profit given back by a single trade before exit (as symbol currency).'
        ),
    ] = None
    averageEndTradeDrawdown: Annotated[
        Optional[float],
        Field(
            description='The average amount of profit given back by all trades before exit (as symbol currency).'
        ),
    ] = None
    maximumDrawdownDuration: Annotated[
        Optional[str],
        Field(
            description='The maximum amount of time to recover from a drawdown (longest time between new equity highs or peaks).'
        ),
    ] = None
    totalFees: Annotated[
        Optional[float], Field(description='The sum of fees for all trades.')
    ] = None


class UpdateBacktestRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project that contains the backtest.',
            examples=[23456789],
        ),
    ]
    backtestId: Annotated[
        str,
        Field(
            description='Id of the backtest to update.',
            examples=['26c7bb06b8487cff1c7b3c44652b30f1'],
        ),
    ]
    name: Annotated[
        Optional[str], Field(description='Name to assign to the backtest.')
    ] = None
    note: Annotated[
        Optional[str], Field(description='Note to attach to the backtest.')
    ] = None


class UpdateFileNameRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project that contains the file.', examples=[23456789]
        ),
    ]
    name: Annotated[
        str, Field(description='The current name of the file.', examples=['file1.py'])
    ]
    newName: Annotated[
        str, Field(description='The new name for the file.', examples=['file2.py'])
    ]
    codeSourceId: Annotated[
        Optional[str],
        Field(
            description="Name of the environment that's creating the request.",
            examples=['MCP Server'],
        ),
    ] = None


class UpdateFileContentsRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(
            description='Id of the project that contains the file.', examples=[23456789]
        ),
    ]
    name: Annotated[
        str,
        Field(
            description='The name of the file to update.',
            examples=['main.py', 'Main.cs'],
        ),
    ]
    content: Annotated[
        str,
        Field(
            description='The new contents of the file.',
            examples=[
                'class CustomClass:\n    def __init__(self):\n        pass\n',
                'public class CustomClass\n{\n    CustomClass()\n    {\n\n    }\n}\n',
            ],
        ),
    ]
    codeSourceId: Annotated[
        Optional[str],
        Field(
            description="Name of the environment that's creating the request.",
            examples=['MCP Server'],
        ),
    ] = None


class UpdateOptimizationRequest(BaseModel):
    optimizationId: Annotated[
        str,
        Field(
            description='Id of the optimization to update.',
            examples=['O-401d3d40b5a0e9f8c46c954a303f3ddd'],
        ),
    ]
    name: Annotated[
        str,
        Field(
            description='Name to assign to the optimization.',
            examples=['New Optimization Name'],
        ),
    ]


class UpdateProjectRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(description='Project Id to which the file belongs.', examples=[23456789]),
    ]
    name: Annotated[
        Optional[str],
        Field(
            description='The new name for the project.', examples=['New Project Name']
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='The new description for the project.',
            examples=['New Project Description'],
        ),
    ] = None


class UpdateProjectNodesRequest(BaseModel):
    projectId: Annotated[
        int,
        Field(description='Project Id to which the nodes refer.', examples=[23456789]),
    ]
    nodes: Annotated[
        Optional[List[str]],
        Field(
            description='List of node Ids the project may use. If you omit this property or pass an empty list, the best node will be automatically selected for backtest, research, and live trading.'
        ),
    ] = None


class Version(BaseModel):
    sdescription: Optional[str] = None
    bpublic: Optional[int] = None
    itimestamp: Optional[datetime] = None
    benchmark_basic: Optional[float] = None
    benchmark_equity_400_minute: Optional[float] = None
    benchmark_equity_1_second: Optional[float] = None
    benchmark_cs_indicator: Optional[float] = None
    benchmark_cs_history: Optional[float] = None
    benchmark_cs_schedule_events: Optional[float] = None
    benchmark_py_basic: Optional[float] = None
    benchmark_py_equity_400_minute: Optional[float] = None
    benchmark_py_equity_1_second: Optional[float] = None
    benchmark_py_indicator: Optional[float] = None
    benchmark_py_history: Optional[float] = None
    benchmark_py_schedule_events: Optional[float] = None
    benchmark_py_universe_coarsefine: Optional[float] = None
    benchmark_cs_universe_coarsefine: Optional[float] = None
    benchmark_py_universe_stateful: Optional[float] = None
    benchmark_cs_universe_stateful: Optional[float] = None
    benchmark_py_universe_stateless: Optional[float] = None
    benchmark_cs_universe_stateless: Optional[float] = None


class FilesUpdateBody(BaseModel):
    RootModel: Union[UpdateFileNameRequest, UpdateFileContentsRequest]


class BasicFilesRequest(BaseModel):
    language: Annotated[
        Language, Field(description='Programming language.', examples=['Py'])
    ]
    files: Annotated[
        List[File],
        Field(
            description='Files to process.',
            examples=['[{"name": "file.py", "content": "fileContent"}]'],
        ),
    ]


class BacktestInitRequest(BaseModel):
    language: Annotated[Language, Field(description='Programming language.')]
    files: Annotated[
        List[File],
        Field(
            description='Files to process. One of the files must have the name main.py (when language=Py) or Main.cs (when language=C#).',
            examples=['[{"name": "main.py", "content": "fileContent"}]'],
        ),
    ]


class ErrorEnhanceRequest(BaseModel):
    language: Annotated[
        Language,
        Field(
            description='Programming language for the code completion.', examples=['Py']
        ),
    ]
    error: Annotated[Error, Field(description='Error message to enhance.')]


class PEP8ConvertRequest(BaseModel):
    files: Annotated[
        List[File],
        Field(
            description='Files of the project.',
            examples=['[{"name": "file.py", "content": "fileContent"}]'],
        ),
    ]


class SearchRequest(BaseModel):
    language: Annotated[
        Language,
        Field(
            description='Programming language of the content to search.',
            examples=['Py'],
        ),
    ]
    criteria: Annotated[
        List[SearchCriteria], Field(description='Criteria for the search.')
    ]


class SearchResponse(BaseModel):
    state: Annotated[Optional[State2], Field(description='State of the search.')] = None
    version: Annotated[
        Optional[float], Field(description='Version of the response.', examples=[2.0])
    ] = None
    retrivals: Annotated[
        Optional[List[SearchRetrieval]], Field(description='List of search results.')
    ] = None
    messageId: Annotated[
        Optional[int], Field(description='Id of the message.', examples=[0])
    ] = None


class AccountResponse(BaseModel):
    organizationId: Annotated[
        Optional[str],
        Field(
            description='The organization Id.',
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ] = None
    creditBalance: Annotated[
        Optional[float], Field(description='The current account balance.')
    ] = None
    card: Annotated[
        Optional[Card], Field(description='The current organizations credit card.')
    ] = None


class AlgorithmPerformance(BaseModel):
    tradeStatistics: Optional[TradeStatistics] = None
    portfolioStatistics: Optional[PortfolioStatistics] = None
    closedTrades: Annotated[
        Optional[List[Trade]],
        Field(description='The algorithm statistics on portfolio.'),
    ] = None


class BacktestInsightsResponse(BaseModel):
    insights: Annotated[
        Optional[List[Insight]], Field(description='Collection of insights.')
    ] = None
    length: Annotated[
        Optional[int], Field(description='Total number of returned insights.')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None


class BacktestResult(BaseModel):
    note: Annotated[
        Optional[str], Field(description='Note on the backtest attached by the user.')
    ] = None
    name: Annotated[Optional[str], Field(description='Name of the backtest.')] = None
    organizationId: Annotated[
        Optional[str],
        Field(
            description='The Id of the orgainization.',
            examples=['d6d62db48592c72e67b534553413b602'],
        ),
    ] = None
    projectId: Annotated[
        Optional[int], Field(description='Id of the project.', examples=[23456789])
    ] = None
    completed: Annotated[
        Optional[bool],
        Field(description='Boolean true when the backtest is completed.'),
    ] = None
    optimizationId: Annotated[
        Optional[str],
        Field(
            description='Optimization task ID, if the backtest is part of an optimization.',
            examples=['O-401d3d40b5a0e9f8c46c954a303f3ddd'],
        ),
    ] = None
    backtestId: Annotated[
        Optional[str],
        Field(
            description='Assigned backtest ID.',
            examples=['26c7bb06b8487cff1c7b3c44652b30f1'],
        ),
    ] = None
    tradeableDates: Annotated[
        Optional[int], Field(description='Number of tradeable days in the backtest.')
    ] = None
    researchGuide: Annotated[
        Optional[ResearchGuide],
        Field(
            description='A power gauge for backtests, time and parameters to estimate the overfitting risk.'
        ),
    ] = None
    backtestStart: Annotated[
        Optional[datetime], Field(description='The starting time of the backtest')
    ] = None
    backtestEnd: Annotated[
        Optional[datetime], Field(description='The ending time of the backtest')
    ] = None
    created: Annotated[
        Optional[datetime], Field(description='Backtest creation date and time.')
    ] = None
    snapshotId: Annotated[
        Optional[int], Field(description='Snapshot Id of this backtest result.')
    ] = None
    status: Annotated[
        Optional[Status], Field(description='Status of the backtest.')
    ] = None
    error: Annotated[Optional[str], Field(description='Backtest error message.')] = None
    stacktrace: Annotated[
        Optional[str], Field(description='Backtest error stacktrace.')
    ] = None
    progress: Annotated[
        Optional[float], Field(description='Progress of the backtest in percent 0-1.')
    ] = None
    hasInitializeError: Annotated[
        Optional[bool],
        Field(description='Indicates if the backtest has error during initialization.'),
    ] = None
    charts: Annotated[
        Optional[Dict[str, ChartSummary]],
        Field(
            description='Charts updates for the live algorithm since the last result packet.'
        ),
    ] = None
    parameterSet: Annotated[
        Optional[Union[List, Dict[str, Union[str, float, int]]]],
        Field(description='Parameters used in the backtest.'),
    ] = None
    rollingWindow: Annotated[
        Optional[Dict[str, AlgorithmPerformance]],
        Field(description='Rolling window detailed statistics.'),
    ] = None
    runtimeStatistics: Annotated[
        Optional[RuntimeStatistics],
        Field(
            description='Runtime banner/updating statistics in the title banner of the live algorithm GUI.'
        ),
    ] = None
    statistics: Annotated[
        Optional[StatisticsResult],
        Field(
            description='Statistics information sent during the algorithm operations.'
        ),
    ] = None
    totalPerformance: Annotated[
        Optional[AlgorithmPerformance],
        Field(description='The algorithm performance statistics.'),
    ] = None
    nodeName: Annotated[Optional[str], Field(description='The backtest node name.')] = (
        None
    )
    outOfSampleMaxEndDate: Annotated[
        Optional[datetime], Field(description='End date of out of sample data.')
    ] = None
    outOfSampleDays: Annotated[
        Optional[int], Field(description='Number of days of out of sample days.')
    ] = None


class BacktestSummaryResult(BaseModel):
    backtestId: Annotated[
        Optional[str],
        Field(
            description='Assigned backtest ID',
            examples=['26c7bb06b8487cff1c7b3c44652b30f1'],
        ),
    ] = None
    status: Annotated[
        Optional[Status], Field(description='Status of the backtest.')
    ] = None
    name: Annotated[Optional[str], Field(description='Name of the backtest.')] = None
    created: Annotated[
        Optional[datetime], Field(description='Backtest creation date and time.')
    ] = None
    progress: Annotated[
        Optional[float], Field(description='Progress of the backtest in percent 0-1.')
    ] = None
    optimizationId: Annotated[
        Optional[str],
        Field(
            description='Optimization task ID, if the backtest is part of an optimization.',
            examples=['O-401d3d40b5a0e9f8c46c954a303f3ddd'],
        ),
    ] = None
    tradeableDates: Annotated[
        Optional[int], Field(description='Number of traadeable days')
    ] = None
    parameterSet: Annotated[
        Optional[Union[List, Dict[str, Union[str, float, int]]]],
        Field(description='Parameters used in the backtest.'),
    ] = None
    snapshotId: Annotated[
        Optional[int], Field(description='Snapshot id of this backtest result.')
    ] = None
    tags: Annotated[
        Optional[List[str]], Field(description='Collection of tags for the backtest.')
    ] = None
    sharpeRatio: Annotated[
        Optional[float],
        Field(
            description='Sharpe ratio with respect to risk free rate; measures excess of return per unit of risk.'
        ),
    ] = None
    alpha: Annotated[
        Optional[float],
        Field(
            description='Algorithm "Alpha" statistic - abnormal returns over the risk free rate and the relationshio (beta) with the benchmark returns.'
        ),
    ] = None
    beta: Annotated[
        Optional[float],
        Field(
            description='Algorithm "beta" statistic - the covariance between the algorithm and benchmark performance, divided by benchmark\'s variance.'
        ),
    ] = None
    compoundingAnnualReturn: Annotated[
        Optional[float],
        Field(
            description='Annual compounded returns statistic based on the final-starting capital and years.'
        ),
    ] = None
    drawdown: Annotated[
        Optional[float], Field(description='Drawdown maximum percentage.')
    ] = None
    lossRate: Annotated[
        Optional[float],
        Field(
            description='The ratio of the number of losing trades to the total number of trades.'
        ),
    ] = None
    netProfit: Annotated[
        Optional[float], Field(description='Net profit percentage.')
    ] = None
    parameters: Annotated[
        Optional[int], Field(description='Number of parameters in the backtest.')
    ] = None
    psr: Annotated[Optional[float], Field(description='Price-to-sales ratio.')] = None
    securityTypes: Annotated[
        Optional[int],
        Field(
            description='The number of security types (QuantConnect.SecurityType) present in the backtest.'
        ),
    ] = None
    sortinoRatio: Annotated[
        Optional[float],
        Field(
            description='Sortino ratio with respect to risk free rate; measures excess of return per unit of downside risk.'
        ),
    ] = None
    trades: Annotated[
        Optional[int], Field(description='Number of trades in the backtest.')
    ] = None
    treynorRatio: Annotated[
        Optional[float],
        Field(
            description='Treynor ratio statistic is a measurement of the returns earned in excess of that which could have been earned on an investment that has no diversifiable risk.'
        ),
    ] = None
    winRate: Annotated[
        Optional[float],
        Field(
            description='The ratio of the number of winning trades to the total number of trades.'
        ),
    ] = None


class BrokerageData(BaseModel):
    authentication: Optional[LiveAuthenticationData] = None
    additionalProperties: Optional[BrokerageId] = None


class Chart(BaseModel):
    name: Annotated[Optional[str], Field(description='Name of the Chart.')] = None
    chartType: Annotated[
        Optional[ChartType],
        Field(description='Type of the Chart. 0=Overlayed, 1=Stacked.'),
    ] = None
    series: Annotated[
        Optional[Dict[str, Series]], Field(description='Series Objects for this Chart.')
    ] = None


class FileParameters(BaseModel):
    file: Annotated[
        Optional[str],
        Field(
            description='Path of the file in the project.',
            examples=['__init__.py', 'project/main.py'],
        ),
    ] = None
    parameters: Annotated[
        Optional[List[ParameterDetail]],
        Field(description='List of parameters detected in the file.'),
    ] = None


class DataProviders(BaseModel):
    QuantConnectBrokerage: Optional[QuantConnectDataProviderSettings] = None
    InteractiveBrokersBrokerage: Optional[InteractiveBrokersDataProviderSettings] = None
    TradierBrokerage: Annotated[
        Optional[TradierDataProviderSettings],
        Field(
            description='This data provider is invalid if you deploy with the Tradier brokerage in the paper environment.'
        ),
    ] = None
    BitfinexBrokerage: Optional[BitfinexSettings] = None
    CoinbaseBrokerage: Optional[CoinbaseDataProviderSettings] = None
    BinanceBrokerage: Optional[
        Union[
            BinanceDataProviderSettings,
            BinanceUSDataProviderSettings,
            BinanceUSDMFuturesDataProviderSettings,
            BinanceCOINFuturesDataProviderSettings,
        ]
    ] = None
    KrakenBrokerage: Optional[KrakenSettings] = None
    PolygonDataFeed: Optional[PolygonDataProviderSettings] = None
    BybitBrokerage: Optional[BybitDataProviderSettings] = None
    OandaBrokerage: Optional[OandaSettings] = None
    CharlesSchwabBrokerage: Optional[CharlesSchwabSettings] = None
    TradeStationBrokerage: Optional[TradeStationSettings] = None
    TastytradeBrokerage: Optional[TastytradeSettings] = None
    AlpacaBrokerage: Optional[AlpacaDataProviderSettings] = None


class QuantConnectBrokerageSettings(BaseModel):
    id: Annotated[Id, Field(description='Id of the module.')]
    holdings: Annotated[
        Optional[List[BrokerageHolding]],
        Field(description='List of holdings for the brokerage.'),
    ] = None
    cash: Annotated[
        Optional[List[CashAmount]], Field(description='List of cash amount.')
    ] = None


class CoinbaseBrokerageSettings(CoinbaseBrokerageAndDataProviderSettings):
    holdings: Annotated[
        Optional[List[BrokerageHolding]],
        Field(description='List of holdings for the brokerage.'),
    ] = None


class BinanceBrokerageSettings(BinanceBrokerageAndDataProviderSettings):
    holdings: Annotated[
        Optional[List[BrokerageHolding]],
        Field(description='List of holdings for the brokerage.'),
    ] = None


class BinanceUSBrokerageSettings(BinanceUSBrokerageAndDataProviderSettings):
    holdings: Annotated[
        Optional[List[BrokerageHolding]],
        Field(description='List of holdings for the brokerage.'),
    ] = None


class BinanceUSDMFuturesBrokerageSettings(
    BinanceUSDMFuturesBrokerageAndDataProviderSettings
):
    holdings: Annotated[
        Optional[List[BrokerageHolding]],
        Field(description='List of holdings for the brokerage.'),
    ] = None


class BinanceCOINFuturesBrokerageSettings(
    BinanceCOINFuturesBrokerageAndDataProviderSettings
):
    holdings: Annotated[
        Optional[List[BrokerageHolding]],
        Field(description='List of holdings for the brokerage.'),
    ] = None


class BybitBrokerageSettings(BybitBrokerageAndDataProviderSettings):
    holdings: Annotated[
        Optional[List[BrokerageHolding]],
        Field(description='List of holdings for the brokerage.'),
    ] = None


class WolverineSettings(BaseModel):
    id: Annotated[Id17, Field(description='Id of the module.')]
    wolverine_on_behalf_of_comp_id: Annotated[
        str,
        Field(
            alias='wolverine-on-behalf-of-comp-id',
            description='Value used to identify the trading firm.',
        ),
    ]
    wolverine_account: Annotated[
        str,
        Field(
            alias='wolverine-account',
            description='Wolverine Execution Services account name.',
        ),
    ]
    cash: Annotated[
        Optional[List[CashAmount]], Field(description='List of cash amount.')
    ] = None
    holdings: Annotated[
        Optional[List[BrokerageHolding]],
        Field(description='List of holdings for the brokerage.'),
    ] = None


class TerminalLinkSettings(BaseModel):
    id: Annotated[Id21, Field(description='Id of the module.')]
    terminal_link_connection_type: Annotated[
        TerminalLinkConnectionType,
        Field(
            alias='terminal-link-connection-type',
            description='Terminal Link Connection Type.',
        ),
    ]
    terminal_link_server_auth_id: Annotated[
        str,
        Field(
            alias='terminal-link-server-auth-id',
            description="Your unique user identifier (UUID). The UUID is a unique integer identifier that's assigned to each Bloomberg Anywhere user. If you don't know your UUID, contact Bloomberg.",
        ),
    ]
    terminal_link_environment: Annotated[
        TerminalLinkEnvironment,
        Field(
            alias='terminal-link-environment', description='The environment to run in.'
        ),
    ]
    terminal_link_server_host: Annotated[
        str,
        Field(
            alias='terminal-link-server-host',
            description='The public IP address of the SAPI AWS server.',
        ),
    ]
    terminal_link_server_port: Annotated[
        int,
        Field(
            alias='terminal-link-server-port',
            description='The port where SAPI is listening. The default port is 8194.',
        ),
    ]
    terminal_link_emsx_broker: Annotated[
        str,
        Field(alias='terminal-link-emsx-broker', description='The EMSX broker to use.'),
    ]
    terminal_link_emsx_account: Annotated[
        str,
        Field(
            alias='terminal-link-emsx-account',
            description='The account to which LEAN should route orders.',
        ),
    ]
    terminal_link_openfigi_api_key: Annotated[
        str,
        Field(
            alias='terminal-link-openfigi-api-key',
            description='The OpenFIGI API key to use for mapping options.',
        ),
    ]
    terminal_link_emsx_team: Annotated[
        Optional[str],
        Field(alias='terminal-link-emsx-team', description='The EMSX team to use.'),
    ] = None
    cash: Annotated[
        Optional[List[CashAmount]], Field(description='List of cash amount.')
    ] = None
    holdings: Annotated[
        Optional[List[BrokerageHolding]],
        Field(description='List of holdings for the brokerage.'),
    ] = None


class RBIBrokerageSettings(BaseModel):
    id: Annotated[Id22, Field(description='Id of the module.')]
    rbi_on_behalf_of_comp_id: Annotated[
        str,
        Field(
            alias='rbi-on-behalf-of-comp-id',
            description='Value used to identify the trading firm.',
        ),
    ]
    rbi_account: Annotated[
        str, Field(alias='rbi-account', description='RBI account name.')
    ]
    cash: Annotated[
        Optional[List[CashAmount]], Field(description='List of cash amount.')
    ] = None
    holdings: Annotated[
        Optional[List[BrokerageHolding]],
        Field(description='List of holdings for the brokerage.'),
    ] = None


class CreateOptimizationRequest(BaseModel):
    projectId: Annotated[
        int, Field(description='Id of the project to optimize.', examples=[23456789])
    ]
    name: Annotated[
        str,
        Field(
            description='Name of the optimization.',
            examples=['Mia First Optimization Job'],
        ),
    ]
    target: Annotated[
        OptimizationTargetStatistic,
        Field(
            description='Target statistic of the optimization to minimize or maximize.'
        ),
    ]
    targetTo: Annotated[
        OptimizationTargetTo, Field(description='Target extremum of the optimization.')
    ]
    targetValue: Annotated[
        Optional[float],
        Field(
            description='Desired value for the optimization target statistic.',
            examples=[1],
        ),
    ] = None
    strategy: Annotated[
        OptimizationStrategy, Field(description='Optimization strategy.')
    ]
    compileId: Annotated[
        str,
        Field(
            description='Optimization compile Id.',
            examples=[
                '5d1f2cba3a0ec7407c566614300502b5-173e0419674daf4144ce7c9931155ca8'
            ],
        ),
    ]
    parameters: Annotated[
        List[OptimizationParameter], Field(description='Optimization parameters.')
    ]
    constraints: Annotated[
        Optional[List[OptimizationConstraint]],
        Field(description='Optimization constraints.'),
    ] = None
    estimatedCost: Annotated[
        float, Field(description='Estimated cost for optimization.', examples=[10])
    ]
    nodeType: Annotated[
        OptimizationNodeType, Field(description='Optimization node type.')
    ]
    parallelNodes: Annotated[
        int,
        Field(description='Number of parallel nodes for optimization.', examples=[4]),
    ]


class CreateOptimizationResponse(BaseModel):
    optimizationId: Annotated[
        Optional[str],
        Field(
            description='Id of the optimization job.',
            examples=['O-401d3d40b5a0e9f8c46c954a303f3ddd'],
        ),
    ] = None
    projectId: Annotated[
        Optional[int],
        Field(
            description='Id of the project the optimization belongs to.',
            examples=[23456789],
        ),
    ] = None
    name: Annotated[Optional[str], Field(description='Name of the optimization.')] = (
        None
    )
    status: Annotated[
        Optional[OptimizationStatus], Field(description='Status of the optimization.')
    ] = None
    nodeType: Annotated[
        Optional[OptimizationNodeType], Field(description='Optimization node type.')
    ] = None
    criterion: Annotated[
        Optional[OptimizationTarget],
        Field(description='Optimization statistical target.'),
    ] = None
    created: Annotated[
        Optional[datetime],
        Field(description='Date and time of when this optimization was created.'),
    ] = None
    psr: Annotated[
        Optional[float], Field(description='Probabilistic Sharpe ratio statistic.')
    ] = None
    sharpeRatio: Annotated[
        Optional[float], Field(description='Sharpe ratio statistic.')
    ] = None
    trades: Annotated[
        Optional[int],
        Field(
            description='Number of trades in the best backtest (based on the criterion) of the optimziation.'
        ),
    ] = None
    cloneId: Annotated[
        Optional[int],
        Field(
            description='Id of project where this current project was originally cloned.'
        ),
    ] = None
    outOfSampleDays: Annotated[
        Optional[int], Field(description='Number out-of-sample days.')
    ] = None
    outOfSampleMaxEndDate: Annotated[
        Optional[datetime], Field(description='End date of out-of-sample data.')
    ] = None
    parameters: Annotated[
        Optional[List[OptimizationParameter]],
        Field(description='Parameters used in this optimization.'),
    ] = None


class EstimateOptimizationRequest(BaseModel):
    projectId: Annotated[
        int, Field(description='Id of the project to optimize.', examples=[23456789])
    ]
    name: Annotated[
        str,
        Field(
            description='Name of the optimization.',
            examples=['Mia First Optimization Job'],
        ),
    ]
    target: Annotated[
        OptimizationTargetStatistic,
        Field(
            description='Target statistic of the optimization to minimize or maximize.'
        ),
    ]
    targetTo: Annotated[
        OptimizationTargetTo, Field(description='Target extremum of the optimization.')
    ]
    targetValue: Annotated[
        Optional[float],
        Field(
            description='Desired value for the optimization target statistic.',
            examples=[1],
        ),
    ] = None
    strategy: Annotated[
        OptimizationStrategy, Field(description='Optimization strategy.')
    ]
    compileId: Annotated[
        Optional[str],
        Field(
            description='Optimization compile Id.',
            examples=[
                '5d1f2cba3a0ec7407c566614300502b5-173e0419674daf4144ce7c9931155ca8'
            ],
        ),
    ] = None
    parameters: Annotated[
        List[OptimizationParameter], Field(description='Optimization parameters.')
    ]
    constraints: Annotated[
        Optional[List[OptimizationConstraint]],
        Field(description='Optimization constraints.'),
    ] = None


class GetObjectStorePropertiesResponse(BaseModel):
    metadata: Annotated[
        Optional[ObjectStoreProperties], Field(description='Object Store properties.')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class Grid(BaseModel):
    xs: Annotated[
        Optional[List[GridChart]],
        Field(description='List of chart in the xs (Extra small) position.'),
    ] = None
    sm: Annotated[
        Optional[List[GridChart]],
        Field(description='List of chart in the sm (Small) position.'),
    ] = None
    md: Annotated[
        Optional[List[GridChart]],
        Field(description='List of chart in the md (Medium) position.'),
    ] = None
    lg: Annotated[
        Optional[List[GridChart]],
        Field(description='List of chart in the lg (Large) position.'),
    ] = None
    xl: Annotated[
        Optional[List[GridChart]],
        Field(description='List of chart in the xl (Extra large) position.'),
    ] = None


class LeanVersionsResponse(BaseModel):
    versions: Annotated[
        Optional[List[LeanVersion]],
        Field(description='List of LEAN versions with their basic descriptions.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class LiveAlgorithm(BaseModel):
    message: Annotated[Optional[str], Field(description='Error message.')] = None
    deployId: Annotated[
        Optional[str],
        Field(
            description='Unique live algorithm deployment identifier (similar to a backtest id).',
            examples=['L-sdf86b7045bb83203e79d2aa6150b321'],
        ),
    ] = None
    status: Annotated[
        Optional[Status2], Field(description='State of the live deployment.')
    ] = None
    cloneId: Annotated[
        Optional[int],
        Field(
            description="The snapshot project Id for cloning the live development's source code."
        ),
    ] = None
    launched: Annotated[
        Optional[datetime],
        Field(description='Datetime the algorithm was launched in UTC.'),
    ] = None
    stopped: Annotated[
        Optional[datetime],
        Field(
            description='Datetime the algorithm was stopped in UTC, null if its still running.'
        ),
    ] = None
    brokerage: Annotated[Optional[str], Field(description='Brokerage')] = None
    securityTypes: Annotated[
        Optional[str], Field(description='Security types detected in the algorithm.')
    ] = None
    datacenter: Annotated[
        Optional[str],
        Field(
            description='Name of the datacenter where the algorithm is physically located.',
            examples=['NY7'],
        ),
    ] = None
    isPublicStreaming: Annotated[
        Optional[bool],
        Field(description='Flag to indicate if public streaming is enabled.'),
    ] = None
    public: Annotated[
        Optional[bool],
        Field(description='Flag to indicate if the algorithm is public.'),
    ] = None
    files: Annotated[
        Optional[List[ProjectFile]],
        Field(description='Files present in the project that contains the algorithm.'),
    ] = None
    runtimeStatistics: Annotated[
        Optional[RuntimeStatistics],
        Field(
            description='Runtime banner/updating statistics in the title banner of the live algorithm GUI. It can be empty if the algorithm is not running.'
        ),
    ] = None
    charts: Annotated[
        Optional[ChartSummary],
        Field(
            description='Chart updates for the live algorithm since the last result packet.'
        ),
    ] = None


class LiveForm(BaseModel):
    brokerageData: Optional[BrokerageData] = None
    dataProvidersData: Annotated[
        Optional[List[BrokerageId]],
        Field(description='The data providers used in the live deployment.'),
    ] = None
    node: Annotated[
        Optional[str], Field(description='Node ID of the live node deployed.')
    ] = None
    notifyInsights: Annotated[
        Optional[NotifyInsights],
        Field(
            description='Indicates if notification should be issued on new insights.'
        ),
    ] = None
    notifyOrderEvents: Annotated[
        Optional[NotifyOrderEvents],
        Field(
            description='Indicates if notification should be issued on new order events.'
        ),
    ] = None
    autoRestart: Annotated[
        Optional[AutoRestart],
        Field(
            description='Indicates if the live algorithm should automatically restart after encountering runtime errors.'
        ),
    ] = None


class LiveAlgorithmResults(BaseModel):
    message: Annotated[Optional[str], Field(description='Error message.')] = None
    deployId: Annotated[
        Optional[str],
        Field(
            description='Unique live algorithm deployment identifier (similar to a backtest id).',
            examples=['L-sdf86b7045bb83203e79d2aa6150b321'],
        ),
    ] = None
    status: Annotated[
        Optional[Status2], Field(description='State of the live deployment.')
    ] = None
    cloneId: Annotated[
        Optional[int],
        Field(
            description="The snapshot project Id for cloning the live development's source code."
        ),
    ] = None
    launched: Annotated[
        Optional[datetime],
        Field(description='Datetime the algorithm was launched in UTC.'),
    ] = None
    stopped: Annotated[
        Optional[datetime],
        Field(
            description='Datetime the algorithm was stopped in UTC, null if its still running.'
        ),
    ] = None
    brokerage: Annotated[Optional[str], Field(description='Brokerage')] = None
    securityTypes: Annotated[
        Optional[str], Field(description='Security types detected in the algorithm.')
    ] = None
    datacenter: Annotated[
        Optional[str],
        Field(
            description='Name of the datacenter where the algorithm is physically located.',
            examples=['NY7'],
        ),
    ] = None
    isPublicStreaming: Annotated[
        Optional[bool],
        Field(description='Flag to indicate if public streaming is enabled.'),
    ] = None
    public: Annotated[
        Optional[bool],
        Field(description='Flag to indicate if the algorithm is public.'),
    ] = None
    files: Annotated[
        Optional[List[ProjectFile]],
        Field(description='Files present in the project that contains the algorithm.'),
    ] = None
    runtimeStatistics: Annotated[
        Optional[RuntimeStatistics],
        Field(
            description='Runtime banner/updating statistics in the title banner of the live algorithm GUI. It can be empty if the algorithm is not running.'
        ),
    ] = None
    charts: Annotated[
        Optional[ChartSummary],
        Field(
            description='Chart updates for the live algorithm since the last result packet.'
        ),
    ] = None
    projectName: Annotated[
        Optional[str],
        Field(description='Name of the project the live algorithm is in.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class LiveAlgorithmListResponse(BaseModel):
    live: Annotated[
        Optional[List[LiveAlgorithmSummary]],
        Field(description='Live algorithms that pass the filters in the request.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class ListObjectStoreResponse(BaseModel):
    path: Annotated[
        Optional[str],
        Field(
            description='Path to the directory in the Object Store.',
            examples=['Mia', 'forecasting_models/momentum'],
        ),
    ] = None
    objects: Annotated[
        Optional[List[ObjectStoreSummary]],
        Field(
            description="List of directories and files stored in the directory at the given path. If the path contains directories, this list of objects doesn't contain the children of those directories."
        ),
    ] = None
    page: Annotated[
        Optional[int],
        Field(description='The current page number in the paginated response.'),
    ] = None
    totalPages: Annotated[
        Optional[int],
        Field(description='The total number of pages in the paginated response.'),
    ] = None
    objectStorageUsed: Annotated[
        Optional[int], Field(description='Size of all objects stored in bytes.')
    ] = None
    objectStorageUsedHuman: Annotated[
        Optional[str],
        Field(
            description='Size of all the objects stored in human-readable format.',
            examples=['2.27 GB'],
        ),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class ListOptimizationResponse(BaseModel):
    optimizations: Annotated[
        Optional[List[CreateOptimizationResponse]],
        Field(description='Collection of summarized optimization objects.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class Node(BaseModel):
    speed: Annotated[
        Optional[float], Field(description='The nodes cpu clock speed in GHz.')
    ] = None
    price: Annotated[
        Optional[NodePrices],
        Field(description='The monthly and yearly prices of the node in US dollars.'),
    ] = None
    cpu: Annotated[Optional[int], Field(description='CPU core count of node.')] = None
    ram: Annotated[Optional[float], Field(description='Size of RAM in Gigabytes.')] = (
        None
    )
    name: Annotated[Optional[str], Field(description='Name of the node.')] = None
    sku: Annotated[
        Optional[str], Field(description='Node type identifier for configuration.')
    ] = None
    description: Annotated[
        Optional[str], Field(description='Description of the node.')
    ] = None
    usedBy: Annotated[
        Optional[str], Field(description='User currently using the node.')
    ] = None
    userProfile: Annotated[
        Optional[str], Field(description='URL of the user using the node.')
    ] = None
    projectName: Annotated[
        Optional[str], Field(description='Project the node is being used for.')
    ] = None
    projectId: Annotated[
        Optional[int],
        Field(
            description='Id of the project the node is being used for.',
            examples=[23456789],
        ),
    ] = None
    busy: Annotated[
        Optional[bool], Field(description='Indicates if the node is currently busy.')
    ] = None
    id: Annotated[Optional[str], Field(description='Full Id of node.')] = None
    assets: Annotated[
        Optional[int],
        Field(description='Maximum number of assets recommended for this node.'),
    ] = None
    host: Annotated[Optional[str], Field(description='Node host.')] = None
    active: Annotated[
        Optional[bool],
        Field(
            description="Indicate if this is an active node for the project. The project will use this node if it's not busy."
        ),
    ] = None
    hasGpu: Annotated[
        Optional[int], Field(description='Indicate if the node has GPU (1) or not (0).')
    ] = None


class ProjectNodes(BaseModel):
    backtest: Annotated[
        Optional[List[Node]], Field(description='Collection of backtest nodes.')
    ] = None
    live: Annotated[
        Optional[List[Node]], Field(description='Collection of live nodes.')
    ] = None
    research: Annotated[
        Optional[List[Node]], Field(description='Collection of research nodes.')
    ] = None


class OptimizationBacktest(BaseModel):
    name: Annotated[Optional[str], Field(description='The backtest name.')] = None
    id: Annotated[Optional[str], Field(description='Id of the backtest.')] = None
    progress: Annotated[
        Optional[float],
        Field(
            description='Progress of the backtest as a percentage from 0-1 based on the days lapsed from start-finish.'
        ),
    ] = None
    exitCode: Annotated[
        Optional[int], Field(description='The exit code of this backtest.')
    ] = None
    statistics: Annotated[
        Optional[List[float]],
        Field(
            description='The backtest statistics results. [alpha, annual standard deviation, annual variance, average loss (%), average win (%), beta, compounding annual return (%), drawdown (%), estimated strategy capacity, expectancy, information ratio, loss rate (%), net profit (%), probabilistic sharpe ratio, profit-loss ratio, sharpe ratio, total fees, total orders, tracking error, treynor ratio, win rate (%)]'
        ),
    ] = None
    parameterSet: Annotated[
        Optional[Union[List, Dict[str, Union[str, float, int]]]],
        Field(description='Parameters used in the backtest.'),
    ] = None
    equity: Annotated[
        Optional[List[List]], Field(description='The backtest equity chart series.')
    ] = None
    startDate: Annotated[
        Optional[datetime], Field(description='The backtest start date.')
    ] = None
    endDate: Annotated[
        Optional[datetime], Field(description='The backtest end date.')
    ] = None
    outOfSampleDays: Annotated[
        Optional[int], Field(description='The backtest out-of-sample day count.')
    ] = None
    outOfSampleMaxEndDate: Annotated[
        Optional[datetime], Field(description='End date of out-of-sample data.')
    ] = None


class Order(BaseModel):
    id: Annotated[Optional[int], Field(description='Order ID.')] = None
    contingentId: Annotated[
        Optional[int],
        Field(description='Order Id to process before processing this order.'),
    ] = None
    brokerId: Annotated[
        Optional[List[str]],
        Field(
            description='Brokerage Id for this order for when the brokerage splits orders into multiple pieces.'
        ),
    ] = None
    symbol: Annotated[Optional[Symbol], Field(description='Symbol of the asset.')] = (
        None
    )
    limitPrice: Annotated[
        Optional[float], Field(description='Limit price of the Order.')
    ] = None
    stopPrice: Annotated[
        Optional[float], Field(description='Stop price of the Order.')
    ] = None
    stopTriggered: Annotated[
        Optional[bool],
        Field(
            description='Indicates if the stop price has been reached, so the limit order has been triggered.'
        ),
    ] = None
    price: Annotated[Optional[float], Field(description='Price of the Order.')] = None
    priceCurrency: Annotated[
        Optional[str], Field(description='Currency for the order price.')
    ] = None
    time: Annotated[
        Optional[datetime],
        Field(description='Gets the UTC time the order was created.'),
    ] = None
    createdTime: Annotated[
        Optional[datetime],
        Field(description='Gets the UTC time this order was created. Alias for Time.'),
    ] = None
    lastFillTime: Annotated[
        Optional[datetime],
        Field(
            description='Gets the UTC time the last fill was received, or null if no fills have been received.'
        ),
    ] = None
    lastUpdateTime: Annotated[
        Optional[datetime],
        Field(
            description='Gets the UTC time this order was last updated, or null if the order has not been updated.'
        ),
    ] = None
    canceledTime: Annotated[
        Optional[datetime],
        Field(
            description='Gets the UTC time this order was canceled, or null if the order was not canceled.'
        ),
    ] = None
    quantity: Annotated[
        Optional[float], Field(description='Number of shares to execute.')
    ] = None
    type: Annotated[
        Optional[Type2],
        Field(
            description='Order type. 0=Market, 1=Limit, 2=StopMarket, 3=StopLimit, 4=MarketOnOpen, 5=MarketOnClose, 6=OptionExercise, 7=LimitIfTouched, 8=ComboMarket, 9=ComboLimit, 10=ComboLegLimit, 11=TrailingStop.'
        ),
    ] = None
    status: Annotated[
        Optional[Status5],
        Field(
            description='Status of the Order. 0=New, 1=Submitted, 2=PartiallyFilled, 3=Filled, 5=Canceled, 6=None, 7=Invalid, 8=CancelPending, 9=UpdateSubmitted.'
        ),
    ] = None
    tag: Annotated[
        Optional[str], Field(description='Tag the order with some custom data.')
    ] = None
    securityType: Annotated[
        Optional[SecurityType],
        Field(
            description='Type of tradable security / underlying asset. 0=Base, 1=Equity, 2=Option, 3=Commodity, 4=Forex, 5=Future, 6=Cfd, 7=Crypto.'
        ),
    ] = None
    direction: Annotated[
        Optional[Direction1],
        Field(
            description='Order Direction Property based off Quantity. 0=Buy, 1=Sell, 2=Hold.'
        ),
    ] = None
    value: Annotated[
        Optional[float],
        Field(
            description='Gets the executed value of this order. If the order has not yet filled, then this will return zero.'
        ),
    ] = None
    orderSubmissionData: Annotated[
        Optional[OrderSubmissionData],
        Field(description='Gets the price data at the time the order was submitted.'),
    ] = None
    isMarketable: Annotated[
        Optional[bool],
        Field(description='Returns true if the order is a marketable order.'),
    ] = None
    properties: Annotated[
        Optional[OrderProperties],
        Field(description='Additional properties of the order.'),
    ] = None
    events: Annotated[
        Optional[List[OrderEvent]], Field(description='The order events.')
    ] = None
    trailingAmount: Annotated[
        Optional[float], Field(description='Trailing amount for a trailing stop order.')
    ] = None
    trailingPercentage: Annotated[
        Optional[bool],
        Field(
            description='Determines whether the trailingAmount is a percentage or an absolute currency value.'
        ),
    ] = None
    groupOrderManager: Annotated[
        Optional[GroupOrderManager],
        Field(
            description='Manager for the orders in the group if this is a combo order.'
        ),
    ] = None
    triggerPrice: Annotated[
        Optional[float],
        Field(
            description='The price which, when touched, will trigger the setting of a limit order at limitPrice.'
        ),
    ] = None
    triggerTouched: Annotated[
        Optional[bool],
        Field(description='Whether or not the triggerPrice has been touched.'),
    ] = None


class Portfolio(BaseModel):
    holdings: Annotated[
        Optional[Dict[str, Holding]],
        Field(
            description='Dictionary of algorithm holdings information, where the key is the Symbol Id.'
        ),
    ] = None
    cash: Annotated[
        Optional[Dict[str, Cash]],
        Field(
            description='Dictionary of algorithm cash currencies information, where the key is the currency ticker.'
        ),
    ] = None


class Project(BaseModel):
    projectId: Annotated[int, Field(description='Project id.', examples=[23456789])]
    organizationId: Annotated[
        str,
        Field(
            description='Orgainization id.',
            examples=['5cad178b20a1d52567b534553413b691'],
        ),
    ]
    name: Annotated[str, Field(description='Name of the project.')]
    modified: Annotated[datetime, Field(description='Modified date for the project.')]
    created: Annotated[datetime, Field(description='Date the project was created.')]
    ownerId: Annotated[int, Field(description='Owner id.')]
    language: Annotated[
        Language, Field(description='Programming language of the project.')
    ]
    collaborators: Annotated[
        Optional[List[Collaborator]], Field(description='List of collaborators.')
    ] = None
    leanVersionId: Annotated[
        Optional[int],
        Field(description='The version of LEAN this project is running on.'),
    ] = None
    leanPinnedToMaster: Annotated[
        Optional[bool],
        Field(
            description='Indicate if the project is pinned to the master branch of LEAN.'
        ),
    ] = None
    owner: Annotated[
        Optional[bool],
        Field(description='Indicate if you are the owner of the project.'),
    ] = None
    description: Annotated[
        Optional[str], Field(description='The project description.')
    ] = None
    channelId: Annotated[Optional[str], Field(description='Channel id.')] = None
    parameters: Annotated[
        Optional[Union[List, Dict[str, Union[str, float, int]]]],
        Field(description='Optimization parameters.'),
    ] = None
    libraries: Annotated[
        Optional[List[Library]], Field(description='The library projects.')
    ] = None
    grid: Annotated[
        Optional[Grid], Field(description='Configuration of the backtest view grid.')
    ] = None
    liveGrid: Annotated[
        Optional[Grid], Field(description='Configuration of the live view grid.')
    ] = None
    paperEquity: Annotated[
        Optional[float],
        Field(description='The equity value of the last paper trading instance.'),
    ] = None
    lastLiveDeployment: Annotated[
        Optional[datetime], Field(description='The last live deployment active time.')
    ] = None
    liveForm: Annotated[
        Optional[LiveForm], Field(description='The last live wizard content used.')
    ] = None
    encrypted: Annotated[
        Optional[bool], Field(description='Indicates if the project is encrypted.')
    ] = None
    codeRunning: Annotated[
        Optional[bool], Field(description='Indicates if the project is running or not.')
    ] = None
    leanEnvironment: Annotated[
        Optional[int], Field(description='LEAN environment of the project running on.')
    ] = None
    encryptionKey: Annotated[
        Optional[EncryptionKey],
        Field(
            description='Text file with at least 32 characters to be used to encrypt the project.'
        ),
    ] = None


class ProjectListResponse(BaseModel):
    projects: Annotated[
        Optional[List[Project]],
        Field(description='List of projects for the authenticated user.'),
    ] = None
    versions: Annotated[
        Optional[List[LeanVersion]], Field(description='List of LEAN versions.')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class ProjectNodesResponse(BaseModel):
    nodes: Annotated[
        Optional[ProjectNodes], Field(description='List of project nodes.')
    ] = None
    autoSelectNode: Annotated[
        Optional[bool],
        Field(
            description='Indicate if the best-performing node is automatically selected.'
        ),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class ReadChartResponse(BaseModel):
    chart: Annotated[Optional[Chart], Field(description='Chart object requested.')] = (
        None
    )
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class InlineResponse2001(BaseModel):
    RootModel: Union[BacktestReportGeneratingResponse, Any]


class InlineResponse2003(BaseModel):
    RootModel: Union[LoadingResponse, ReadChartResponse]


class BacktestOrdersResponse(BaseModel):
    orders: Optional[List[Order]] = None
    length: Annotated[
        Optional[int], Field(description='Total number of returned orders')
    ] = None


class BacktestResponse(BaseModel):
    backtest: Annotated[
        Optional[BacktestResult],
        Field(description='Details on the result of the backtest.'),
    ] = None
    debugging: Annotated[
        Optional[bool],
        Field(description='Indicates if the backtest is run under debugging mode.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class BacktestSummaryResponse(BaseModel):
    backtests: Annotated[
        Optional[List[BacktestSummaryResult]],
        Field(description='Collection of backtest summaries for a project.'),
    ] = None
    count: Annotated[
        Optional[int],
        Field(description='Number of backtest summaries retrieved in the response.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class CreateCompileResponse(BaseModel):
    compileId: Annotated[
        Optional[str],
        Field(
            description='Compile Id for a successful build.',
            examples=[
                '5d1f2cba3a0ec7407c566614300502b5-173e0419674daf4144ce7c9931155ca8'
            ],
        ),
    ] = None
    state: Annotated[
        Optional[State4], Field(description='The current state of the compile job.')
    ] = None
    parameters: Annotated[
        Optional[List[FileParameters]],
        Field(
            description='List of files and their associated parameters detected during compilation.'
        ),
    ] = None
    projectId: Annotated[
        Optional[int],
        Field(
            description='Id of the project you requested to compile.',
            examples=[23456789],
        ),
    ] = None
    signature: Annotated[
        Optional[str], Field(description='Signature key of compilation.')
    ] = None
    signatureOrder: Annotated[
        Optional[List[str]],
        Field(description='Signature order of files to be compiled.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class CreateLiveAlgorithmRequest(BaseModel):
    versionId: Annotated[
        str,
        Field(
            description='The version of the Lean used to run the algorithm. -1 is master, however, sometimes this can create problems with live deployments. If you experience problems using, try specifying the version of Lean you would like to use.',
            examples=['-1'],
        ),
    ]
    projectId: Annotated[int, Field(description='Project Id.', examples=[23456789])]
    compileId: Annotated[
        str,
        Field(
            description='Compile Id.',
            examples=[
                '5d1f2cba3a0ec7407c566614300502b5-173e0419674daf4144ce7c9931155ca8'
            ],
        ),
    ]
    nodeId: Annotated[
        str,
        Field(
            description='Id of the node that will run the algorithm.',
            examples=['LN-c54129e1b4f667613d3f34542b787771'],
        ),
    ]
    brokerage: Annotated[
        Union[
            QuantConnectBrokerageSettings,
            InteractiveBrokersBrokerageSettings,
            TradierBrokerageSettings,
            BitfinexSettings,
            CoinbaseBrokerageSettings,
            BinanceBrokerageSettings,
            BinanceUSBrokerageSettings,
            BinanceUSDMFuturesBrokerageSettings,
            BinanceCOINFuturesBrokerageSettings,
            TradingTechnologiesBrokerageSettings,
            KrakenSettings,
            BybitBrokerageSettings,
            OandaSettings,
            WolverineSettings,
            CharlesSchwabSettings,
            RBIBrokerageSettings,
            TerminalLinkSettings,
            TradeStationSettings,
            TastytradeSettings,
            AlpacaBrokerageSettings,
        ],
        Field(description='Brokerage configuration for the live algorithm.'),
    ]
    dataProviders: Annotated[
        Optional[DataProviders],
        Field(
            description='Dictionary of data provider configurations to be used in the live algorithm. Provide at least one. The order in which you define the providers defines their order of precedence.'
        ),
    ] = {'QuantConnectBrokerage': {'id': 'QuantConnectBrokerage'}}


class CreateLiveAlgorithmResponse(BaseModel):
    responseCode: Annotated[
        Optional[str], Field(description='Response code of the request.')
    ] = None
    source: Annotated[Optional[str], Field(description='Source of the API call.')] = (
        None
    )
    deployId: Annotated[
        Optional[str],
        Field(
            description='Id of the live deployment.',
            examples=['L-141106d80de1da9a9f85ea07c06bf7b6'],
        ),
    ] = None
    versionId: Annotated[
        Optional[int],
        Field(description='Id of the LEAN version deployed.', examples=[17202]),
    ] = None
    projectId: Annotated[
        Optional[int],
        Field(description='Id of the project deployed.', examples=[24058693]),
    ] = None
    live: Annotated[
        Optional[LiveAlgorithm], Field(description='Summary of the algorithm created.')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class LivePortfolioResponse(BaseModel):
    portfolio: Optional[Portfolio] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class LiveOrdersResponse(BaseModel):
    orders: Annotated[
        Optional[List[Order]], Field(description='Collection of orders.')
    ] = None
    length: Annotated[
        Optional[int], Field(description='Total number of returned orders')
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None


class Optimization(BaseModel):
    optimizationId: Annotated[
        Optional[str],
        Field(
            description='Id of the optimization.',
            examples=['O-401d3d40b5a0e9f8c46c954a303f3ddd'],
        ),
    ] = None
    snapshotId: Annotated[
        Optional[int],
        Field(description='Snapshot Id of this optimization.', examples=[24013333]),
    ] = None
    projectId: Annotated[
        int,
        Field(
            description='Id of the project the optimization belongs to.',
            examples=[23456789],
        ),
    ]
    name: Annotated[Optional[str], Field(description='Name of the optimization.')] = (
        None
    )
    status: Annotated[
        Optional[OptimizationStatus], Field(description='Status of the optimization.')
    ] = None
    nodeType: Annotated[
        Optional[OptimizationNodeType], Field(description='Optimization node type.')
    ] = None
    parallelNodes: Annotated[
        Optional[int],
        Field(
            description='Number of parallel nodes for the optimization.', examples=[4]
        ),
    ] = None
    criterion: Annotated[
        Optional[OptimizationTarget],
        Field(description='Optimization statistical target.'),
    ] = None
    runtimeStatistics: Annotated[
        Optional[OptimizationRuntimeStatistics],
        Field(
            description='Dictionary representing a runtime banner/updating statistics for the optimization.'
        ),
    ] = None
    constraints: Annotated[
        Optional[List[OptimizationConstraint]],
        Field(description='Optimization constraints.'),
    ] = None
    parameters: Annotated[
        Optional[List[OptimizationParameter]],
        Field(description='Optimization parameters.'),
    ] = None
    backtests: Annotated[
        Optional[Dict[str, OptimizationBacktest]],
        Field(description='Dictionary of optimization backtests.'),
    ] = None
    strategy: Annotated[
        Optional[OptimizationStrategy], Field(description='Optimization strategy.')
    ] = None
    requested: Annotated[
        Optional[datetime], Field(description='Optimization requested date and time.')
    ] = None
    optimizationTarget: Annotated[
        Optional[OptimizationTargetStatistic],
        Field(description='Statistic to be optimized.'),
    ] = None
    targetValue: Annotated[
        Optional[float],
        Field(
            description='Desired value for the optimization target statistic.',
            examples=[1],
        ),
    ] = None
    gridLayout: Annotated[
        Optional[List[GridChart]],
        Field(description='List with grid charts representing the grid layout.'),
    ] = None
    outOfSampleMaxEndDate: Annotated[
        Optional[datetime], Field(description='End date of out of sample data.')
    ] = None
    outOfSampleDays: Annotated[
        Optional[int], Field(description='Number of days of out of sample days.')
    ] = None


class ReadOptimizationResponse(BaseModel):
    optimization: Annotated[
        Optional[Optimization],
        Field(description='Optimization object requested to read.'),
    ] = None
    success: Annotated[
        Optional[bool], Field(description='Indicate if the API request was successful.')
    ] = None
    errors: Annotated[
        Optional[List[str]], Field(description='List of errors with the API call.')
    ] = None
